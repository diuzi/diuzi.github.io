<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>daily_leetcode_2020_1123_452_用最少数量的箭引爆气球</title>
      <link href="/2020/11/23/daily-leetcode-2020-1123-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/"/>
      <url>/2020/11/23/daily-leetcode-2020-1123-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><pre><code>输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2输入：points = [[1,2]]输出：1输入：points = [[2,3],[2,3]]输出：1</code></pre><h1 id="区间合并">2 区间合并</h1><p>如果两个气球能被一箭射掉，那么射的点肯定在<code>两个气球的交集</code>里，所以我们可以考虑从求交集入手。</p><p>我们维护一个<code>可射区间</code>,每次取两个气球，看他们是否有交集，如果有交集，那么就更新这个可射区间(他们的交集)；如果没有交集，那么也要更新可射区间为下一个气球，这也意味这要多射一箭(res+=1)</p><p>为了方便将射掉的气球标记掉、在寻找交集的时候使得气球”连续”,所以事先对所有气球排序。(如果事先不排序话，就需要两层循环)</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> points<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> points<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        points<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        p <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># jdi147.com 可射区间</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># jdi147.com 有交集</span>            <span class="token keyword">if</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                p <span class="token operator">=</span> <span class="token punctuation">[</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min<span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                p <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res</code></pre><h1 id="贪心">3 贪心</h1><p>贪心贪的是什么？</p><blockquote><p>在能射掉这个气球的情况下，尽可能地射更多的气球。</p></blockquote><p>对于一个气球[start, end],想要将这个气球射掉，那么射气球的点肯定在这个区间里。</p><p>假设有两个气球，要一箭射掉这两个气球，那么就意味着射的点在<code>两个气球的交集</code>里，</p><p>那么问题来了，在这个区间里可能有好几个取值，取那个去射呢？</p><p>解决办法来了，如果我们的气球是有序的，即按<code>"从小到大"</code>排列，<strong>在射掉小气球的情况下，又要射掉大气球，那么这个点最好取小气球的峰值，即右端点，才更有可能接近大气球</strong></p><p>也就是说，射的点肯定取的是右端点，这也就是说要保证我们的从小到大实际上是按照<code>右端点</code>排序的,</p><p>下面结合代码理解</p><pre class=" language-python"><code class="language-python">        <span class="token keyword">if</span> <span class="token operator">not</span> points<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        points<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">1</span>        value <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">""" 当前气球和下个气球没有交集 """</span>            <span class="token keyword">if</span> value <span class="token operator">&lt;</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>                value <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1122_242_有效的字母异位词</title>
      <link href="/2020/11/22/daily-leetcode-2020-1122-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>/2020/11/22/daily-leetcode-2020-1122-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><pre><code>输入: s = "anagram", t = "nagaram"输出: true输入: s = "rat", t = "car"输出: false</code></pre><h1 id="排序">2 排序</h1><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> sorted<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> sorted<span class="token punctuation">(</span>t<span class="token punctuation">)</span></code></pre><h1 id="哈希映射">3 哈希映射</h1><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">map_method</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        result_map <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>            result_map<span class="token punctuation">[</span>ch<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> ch <span class="token keyword">in</span> t<span class="token punctuation">:</span>            result_map<span class="token punctuation">[</span>ch<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> result_map<span class="token punctuation">[</span>ch<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1120_147_对链表进行插入排序</title>
      <link href="/2020/11/20/daily-leetcode-2020-1120-147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/11/20/daily-leetcode-2020-1120-147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>对链表进行插入排序。</p><p>插入排序算法：</p><p>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。<br>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。<br>重复直到所有输入数据插入完为止。</p><pre><code>输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><h1 id="题解">2 题解</h1><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertionSortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        在链表的题目中，无论是增删改查，增加哑节点是一个非常好的编程习惯，特别是在节点删除的时候能起到非常重要的作用        在遍历排序中，不至于让我们丢掉了头节点        我们需要一个while循环去遍历链表&amp;#123;                每次比较 相邻的两个节点值的大小，如果是升序的那就没有不要操作了，链表前进一步，继续取两个比较                如果不是，那么我们就要 将后面这个节点插入到 前面已经有序的链表中，                那么怎么插呢，那必须得从 前面已经有序的链表 从头开始比较大小， 找的合适它得位置(所以这里也得一个while循环)                将其插入（常规操作)                插入之后呢，是不是得回到原先遍历得位置， 继续遍历        &amp;#125;        """</span>        <span class="token comment" spellcheck="true"># jdi147.com 哑节点</span>        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>float<span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head        <span class="token keyword">while</span> head <span class="token operator">and</span> head<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            <span class="token keyword">if</span> head<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                head <span class="token operator">=</span> head<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token triple-quoted-string string">""" 寻找待插入节点 的 合适位置， pre为待插位置的前驱节点 """</span>                pre <span class="token operator">=</span> dummy                <span class="token keyword">while</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next                insert <span class="token operator">=</span> head<span class="token punctuation">.</span>next                head<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next  <span class="token comment" spellcheck="true"># jdi147.com insert被插到前面去了，所以head得跳过insert连接到下一个节点</span>                insert<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> insert        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1119_283_移动零</title>
      <link href="/2020/11/19/daily-leetcode-2020-1119-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2020/11/19/daily-leetcode-2020-1119-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><pre><code>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 输入: [0,1,0,3,12]输出: [1,3,12,0,0]必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。</code></pre><h1 id="代码">2 代码</h1><p>这题考的就是个双指针</p><h2 id="双指针">2.1 双指针</h2><pre class=" language-python"><code class="language-python">        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token triple-quoted-string string">""" i指向不为0的元素， j指向不为0元素可以放的位置，遍历过程种，遇见不为0的元素就往前放"""</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">></span> j<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span></code></pre><h2 id="两次遍历">2.2 两次遍历</h2><pre class=" language-python"><code class="language-python">        j<span class="token punctuation">,</span> nums_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token triple-quoted-string string">""" 遇见不为0的放前面 """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>nums_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token triple-quoted-string string">""" 将最后剩下的位置填补0 """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>j<span class="token punctuation">,</span> nums_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1118_134_加油站</title>
      <link href="/2020/11/18/daily-leetcode-2020-1118-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
      <url>/2020/11/18/daily-leetcode-2020-1118-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><pre><code>输入: gas  = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。输入: gas  = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。</code></pre><h1 id="代码">2 代码</h1><h2 id="常规思路">2.1 常规思路</h2><p>我们用一个两层循环，第一层遍历每个加油站，对于当前加油站j,进行第二层循环，判断其能否行的通，注释已经很详细了，这里就不展开细讲了。</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> gas<span class="token punctuation">,</span> cost<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        gas_len <span class="token operator">=</span> len<span class="token punctuation">(</span>gas<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>gas_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">""" not run """</span>            <span class="token keyword">if</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            dp <span class="token operator">=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># jdi147.com 记录当前油的剩余量</span>            idx<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token punctuation">,</span> i  <span class="token comment" spellcheck="true"># jdi147.com； idx 记录起点</span>            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                <span class="token triple-quoted-string string">""" 预估当前油量能否到下一站 """</span>                j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> gas_len<span class="token punctuation">)</span> <span class="token operator">%</span> gas_len                dp <span class="token operator">+=</span> gas<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">if</span> dp <span class="token operator">&lt;</span> cost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                <span class="token triple-quoted-string string">""" 走到起点了， """</span>                <span class="token keyword">if</span> j <span class="token operator">==</span> idx<span class="token punctuation">:</span>                    <span class="token keyword">return</span> idx                <span class="token triple-quoted-string string">""" 走下一站 """</span>                dp <span class="token operator">-=</span> cost<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></code></pre><h2 id="一次遍历">2.2 一次遍历</h2><p>此代码参考评论区陈允怀大佬代码。</p><p>根据大佬的笔记和自己的理解尽量直白地说一下这种思路。</p><p>从宏观上来讲(不考虑从那个点开始的情况下,假设只有起点到终点，看车的油能否到终点), 我们只需计算 所有加油站油的和 与 所有路程消耗油的和 的差<code>rest_sum</code>，只要这个差大于等于0，那么就说这个圈可以走下来。你可能觉得这不现实，可能某个站油多，某个站油少，中间某个点走不下去。</p><p>那这样，走不下去的这个点我跳过，从下一个点开始<code>重新走</code>, 即重新选起点，<strong>按这样的思路只需一次遍历</strong></p><p>那么问题又来了，你是不是觉得你选后面的点作为起点，你一次遍历完结束，根本没有考虑<code>走到数组末尾需要从头开始判断,直到回到这个点</code>, </p><p>事实上这时只需判断<code>rest_sum</code>的值。</p><p><strong>下面结合图进行分析</strong></p><blockquote><p>rest(i-&gt;j)表示从i到j点剩余的油</p></blockquote><p>我们从起点出发，一直走啊走，到一个点就加油,走到<code>i-k</code>这个点的时候，车剩的油和加的油和起来都不能到下一个点了，我们跳过这个点。选<code>i-k+ 1</code>开始走,到<code>i-1</code>这个点时又发现走不下去了。于是我们选<code>i</code>这个开始走。一路油都够，一直走到终点。</p><p> 这时如果剩余的油大于0哪么我们就说选i这个点可以。那么你是不是疑感”前面起点到i这些点你没有判断呀”。</p><p>我们假设油刚刚好够,那么</p><ol><li><code>rest_ sum=0,</code></li><li>前面有两个点都不能通过,说明<code>rest(起点-&gt;i)&lt;0,</code></li><li>又<code>rest_ sum = rest(起点-&gt;i)+rest(i-&gt;终点)，则rest(i-&gt;终点)&gt;0,</code>也就是说到终点油是有剩余的,</li></ol><p><strong>带着剩余的油从终点出发一定是可以到<code>i</code>的，为什么呢，因为我剩余的油肯定够补给从起点到i-1所缺的油（上面三个公式），<em>终点剩余的油大于等于前半段缺的油，那么终点剩余的油肯定大于等于前半段每个点缺的油。</em></strong></p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201118224438085.png" alt="image-20201118224438085"></p><p>结论：</p><p>从某个点开始，如果能够蹦跶到数组末尾，而且最后rest_sum&gt;=0,那么就说这个点可以，不用去判断从数组末尾到这个点(环的另一半)，原因就是上面三个公式。</p><p>代码：</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">method2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> gas<span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">:</span>        rest_sum<span class="token punctuation">,</span> run<span class="token punctuation">,</span> start_point <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>gas<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            rest_sum <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            run <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">if</span> run <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                start_point <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>                run <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> rest_sum <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">else</span> start_point</code></pre><p>画完图发现后来发现，其实最后走到的是数组头 gas[i]，最后计算的是 <code>gas[数组末尾]-cost[数组末尾]</code>，实际上判断的是能够走到数组头，表述有误，面这样讲解更好理解一些吧。</p><h1 id="参考">3 参考</h1><ol><li><a href="https://leetcode-cn.com/problems/gas-station/">134. 加油站</a>评论区陈允怀大佬。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1117_1030_距离顺序排列矩阵单元格</title>
      <link href="/2020/11/17/daily-leetcode-2020-1117-1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E4%B8%BE%E8%AF%81%E5%8D%95%E5%85%83%E6%A0%BC/"/>
      <url>/2020/11/17/daily-leetcode-2020-1117-1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E4%B8%BE%E8%AF%81%E5%8D%95%E5%85%83%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。</p><p>另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。</p><p>返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）</p><pre><code>输入：R = 1, C = 2, r0 = 0, c0 = 0输出：[[0,0],[0,1]]解释：从 (r0, c0) 到其他单元格的距离为：[0,1]输入：R = 2, C = 2, r0 = 0, c0 = 1输出：[[0,1],[0,0],[1,1],[1,0]]解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2][[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。入：R = 2, C = 3, r0 = 1, c0 = 2输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。提示：1 &lt;= R &lt;= 1001 &lt;= C &lt;= 1000 &lt;= r0 &lt; R0 &lt;= c0 &lt; C</code></pre><h1 id="代码">2 代码</h1><p>这个题好像没有什么好讲的</p><h2 id="优雅的python">2.1 优雅的python</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">allCellsDistOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> R<span class="token punctuation">:</span> int<span class="token punctuation">,</span> C<span class="token punctuation">:</span> int<span class="token punctuation">,</span> r0<span class="token punctuation">:</span> int<span class="token punctuation">,</span> c0<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> sorted<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>R<span class="token punctuation">)</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> p<span class="token punctuation">:</span>abs<span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>r0<span class="token punctuation">)</span><span class="token operator">+</span>abs<span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>c0<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="桶排序">2.2 桶排序</h2><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">bucket_sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> R<span class="token punctuation">,</span> C<span class="token punctuation">,</span> r0<span class="token punctuation">,</span> c0<span class="token punctuation">)</span><span class="token punctuation">:</span>        bucket <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>R <span class="token operator">+</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>                dist <span class="token operator">=</span> abs<span class="token punctuation">(</span>i <span class="token operator">-</span> r0<span class="token punctuation">)</span> <span class="token operator">+</span> abs<span class="token punctuation">(</span>j <span class="token operator">-</span> c0<span class="token punctuation">)</span>                bucket<span class="token punctuation">[</span>dist<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> bucket<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>b<span class="token punctuation">)</span></code></pre><h1 id="bfs">3 bfs</h1><p>参考：</p><p>作者：lucy-17<br>链接：<a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/solution/bfs-by-lucy-17-3/">https://leetcode-cn.com/problems/matrix-cells-in-distance-order/solution/bfs-by-lucy-17-3/</a></p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">bfs_sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> R<span class="token punctuation">,</span> C<span class="token punctuation">,</span> r0<span class="token punctuation">,</span> c0<span class="token punctuation">)</span><span class="token punctuation">:</span>        queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>r0<span class="token punctuation">,</span> c0<span class="token punctuation">]</span><span class="token punctuation">]</span>        visited <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> c0<span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            head <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">)</span>            <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> head<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> head<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> head<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> head<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> R <span class="token operator">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> C <span class="token operator">and</span> tuple<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                    visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tuple<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1116_406根据身高重建队列</title>
      <link href="/2020/11/16/daily-leetcode-2020-1116-406%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
      <url>/2020/11/16/daily-leetcode-2020-1116-406%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p><pre><code>输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</code></pre><h1 id="题解">2 题解</h1><p>将队列按h降序、k升序排序，然后做插入操作：</p><p>对于(hi,ki),将它插入下标位ki的位置即可。</p><p>这样做的目的就是: 按高低进行排序，高个子在前面，矮个子在后面，对于矮个子(hi,ki)，插到ki位置，就表示前面有ki个比它高的\(这便是题目要求的)</p><p>示例：</p><pre><code>对于输入 [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]排序后:[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]遍历排序后的队列:[7,0], res = [[7,0]][7,1], res = [[7,0], [7,1]][6,1], res = [[7,0], [6,1], [7,1]][5,0], res = [[5,0], [7,0], [6,1], [7,1]][5,2], res = [[5,0], [7,0], [5,2], [6,1], [7,1]][4,4], res = [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</code></pre><ol><li><strong>高个子站好了，矮个子往高个子里面插，矮个子的k影响不到高个子的k</strong></li></ol><h1 id="代码">3 代码</h1><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reconstructQueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> people<span class="token punctuation">)</span><span class="token punctuation">:</span>        people<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> list<span class="token punctuation">(</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> people<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        people <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>reconstructQueue<span class="token punctuation">(</span>people<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    solution<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase理论入门</title>
      <link href="/2020/11/15/Hbase%E7%90%86%E8%AE%BA%E5%85%A5%E9%97%A8/"/>
      <url>/2020/11/15/Hbase%E7%90%86%E8%AE%BA%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概念">1 概念</h1><p>HBase是Apache的Hadoop项目的子项目，是Hadoop Database的简称。构建在 Apache Hadoop和 Apache ZooKeeper之上。</p><p>一个<strong>高可靠性、高性能、面向列、可伸缩</strong>的分布式存储系统，利用HBase技术可在廉价的机器上搭建起大规模结构化存储集群。</p><p>HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。</p><p>特点：</p><ul><li><strong>海量存储：</strong>HBase适合存储PB级别的海量数据，在PB级别的数据以及采用廉价PC存储的情况下，能在几十到百毫秒内返回数据。这与HBase的记忆扩展性息息相关。正是因为HBase的良好扩展性，才为海量数据的存储提供了便利。</li><li><strong>列式存储：</strong>列式存储，HBase是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定，而不用指定列。</li><li><strong>极易扩展：</strong>HBase的扩展性主要体现在两个方面，一个是基于上层处理能力（RegionServer）的扩展，一个是基于存储能力（HDFS）的扩展。</li><li><strong>高并发：</strong>目前大部分使用HBase的架构，都是采用廉价PC，因此单个IO的延迟其实并不小，一般在几十到上百ms之间。这里说的高并发，主要是在并发的情况下，HBase的单个IO延迟下降并不多。</li><li><strong>稀疏：</strong>稀疏主要是针对HBase列的灵活性，在列族中，可以指定任意多的列，在列数据为空的情况下，是不会占用存储空间</li></ul><p>概括：</p><ol><li>HBase底层存储并非必须是HDFS文件系统，但是HDFS是最佳选择</li><li>该技术来源于Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力</li><li>一个<strong>高可靠性、高性能、面向列、可伸缩</strong>的分布式存储系统。Hbase参考了谷歌的BigTable建模，使用HDFS作为底层存储，使用Zookeeper作为协同服务组件。</li><li>安装Hbase必须安装jdk,Hbase是Java编写</li></ol><h1 id="数据模型">2 数据模型</h1><ul><li><p><strong>Namespace（表命名空间）：</strong>表命名空间不是强制的，如果想把多个表分到一个组去统一管理的时候才会用到表命名空间。</p></li><li><p><strong>Table（表）：</strong>一个表由多行组成。</p></li><li><p><strong>Row（行）：</strong>一个行键和一个或多个列组成</p></li><li><p><strong>Column Family（列族）：</strong>列族是多个列的集合。</p></li><li><p><strong>Column Qualifier（列）：</strong>列由 <strong>列族</strong>和 <strong>列限定符</strong>组成，列是可以随意定义的，一个行中的列不限名字，不限数量，只限定列族。</p><p>如：</p><p>content:pdf</p><p>content是列族，pdf是列限定符。</p></li></ul><ul><li><p><strong>Cell（单元格）：</strong>单元格是行，列族和列限定符的组合，它包含一个值和一个时间戳，时间戳表示值的版本。</p></li><li><p><strong>Timestamp（时间戳/版本号）：</strong>用来标定同一个列中多个Cell的版本号。当在插入数据的时候，如果不指定版本号，系统会自动采用系统的当前时间戳来作为版本号，也可以手动指定一个数字作为版本号。</p></li><li><p><strong>Rowkey（行键）：</strong>用来标识表中唯一的一行数据，以字节数组形式存储，类似关系型数据库中表的主键。<strong>rowkey在HBase中时严格按照字典序排序的</strong>。</p></li></ul><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201111162945221.png" alt="image-20201111162945221"></p><hr><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201111163541421.png" alt="image-20201111163541421"></p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201111164540933.png" alt="image-20201111164540933"></p><p><strong>时间戳按降序存储，取模个cell的值默认取版本最新的值。取列中不存在的值将不返回任何值</strong>。</p><h1 id="架构">3 架构</h1><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201111172040908.png" alt="image-20201111172040908"></p><h2 id="主从结构">3.1 主从结构</h2><p>Master:</p><ol><li>负责RegionServer的Region分配和负载均衡。</li><li>发现失效的RegionServer并重新分配Region；</li><li>处理Schema更新请求（表的创建、删除、修改、列族的增加等）。</li><li>管理namespace和table的元数据（实际存储在HDFS上）。</li></ol><p>RegionServer:</p><ol><li>存放和管理本地Region。</li><li>读写HDFS，管理Table中的数据。</li><li>处理Client的IO请求（Client从Master中获取元数据，找到RowKey所在的Region/RegionServer后，类HDFS）。</li><li>负责region的切分和合并</li></ol><ol><li><strong>HDFS</strong></li></ol><ul><li>为HBase提供最终的底层数据存储服务（包括元数据和表数据）</li><li>同时为HBase提供高可用（HLog）的支持</li></ul><ol start="2"><li><strong>Zookeeper</strong></li></ol><ul><li>为HBase提供Failover机制，选举master，避免master单点故障问题；</li><li><strong>存储所有Region的寻址入口，保存<code>hbase:meta</code>表信息；</strong></li><li>实时监控RegionServer的状态，将RegionServer的上线和下线信息实时通知给master；</li><li>存储HBase的Schema，包括有哪些Table，每个Table有哪些Column Family</li></ul><ol start="3"><li><p><strong>Client</strong></p><p>Client使用HBase的RPC机制与HMaster、RegionServer进行通信，Client与Master进行管理类通信，与RegionServer进行数据操作类通信。Client包含了访问HBase的接口，另外Client还维护了对应的cache来加速HBase的访问，</p></li></ol><h2 id="RegionServer结构">3.2 RegionServer结构</h2><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201111174323169.png" alt="image-20201111174323169"></p><ol><li><p>region, 可以理解为一张表或者一张表的横向切分后的一段，Hbase会自动将表切分成多个region, 初始时一张表只有一个region。</p></li><li><p>一个region包含某些Strore, 一个store就相当于一个列族</p></li><li><p>一个列族里面有一个Memstore和零个或多个StoreFile,当写入数据时，首先写入MemStore中(先这样理解)，当Memstore中的数据达到一定程度时，会flush到一个Storefile（存储在Hfile）</p></li><li><p>当一个Strore中的Storefile数量达到一定程度时，就会进行StoreFile的合并操作。</p></li><li><p>当region中总的StoreFile达到一定体量后，便会触发切分region的操作。将region切分成两个子region，然后由HMaster根据负载情况分配到HRegionServer中。</p></li><li><p>WAL预写日志，在将数据写入MemStore前，会先写入WAL中，再进行前面的第二部操作。这样的好处是当Region所在的机器宕机后，可以从WAL中恢复数据。（<strong>在写入MemStore中会对数据根据rowKey进行排序操作</strong>)</p></li><li><p>BlockCache，读缓存，用于在内存中缓存经常被读的数据。Least Recently Used (LRU) 数据在存满时会被失效。</p></li></ol><h1 id="原理">4 原理</h1><h2 id="region合并">4.1 region合并</h2><h3 id="小合并（Minor-Compaction）">4.1.1 小合并（Minor Compaction）</h3><p>当MemStore达到<code>hbase.hregion.memstore.flush.size</code>大小的时候会将数据刷写到磁盘，生成StoreFile。随着业务的发展，数据量会越来越大，会产生很多的小文件，对于HBase的数据读取，如果要扫描大量的小文件，会导致性能很差，因此需要将这些小文件合并成一个大一点的文件。</p><p>小合并，就是把多个小的StoreFile组合在一起，形成一个较大的StoreFile，步骤如下：</p><ol><li>分别读取出待合并的StoreFile文件的KeyValues，并顺序地写入到位于<code>/hbase/.tmp</code>目录下的临时文件中；</li><li>将临时文件移动到对应的Region目录中；</li><li>将合并的输入文件路径和输出路径封装成KeyValues写入WAL日志，并打上compaction标记，最后强制执行sync；</li><li>将对应region数据目录下的合并的输入文件全部删除，合并完成。</li></ol><p><em>小合并一般速度比较快，对业务的影响也比较小。本质上，小合并就是使用短时间的IO消耗以及带宽消耗换取后续查询的低延迟。在Minor Compaction过程中，达到TTL（记录保留时间）的数据会被移除，但是由墓碑标记的记录不会被移除，因为墓碑标记可能存储在不同HFile中，合并可能会跨过部分墓碑标记。</em></p><h3 id="大合并（Major-Compation">4.1.2 大合并（Major Compation)</h3><p>大合并就是将一个Region下的所有StoreFile合并成一个大的StoreFile文件。在大合并的过程中，<strong>之前删除的行和过期的版本都会被删除</strong>。大合并一般一周做一次，由<code>hbase.hregion.majorcompaction</code>参数控制。大合并的影响一般比较大，尽量避免同一时间多个Region进行合并，因此HBase通过<code>hbase.hregion.majorcompaction.jitter</code>参数来进行控制，用于防止多个Region同时进行大合并。</p><p>具体算法：</p><p><code>hbase.hregion.majorcompaction</code>参数的值乘以一个随机分数，这个随机分数不能超过<code>hbase.hregion.majorcompation.jitter</code>的值（默认为0.5）。</p><p>通过<code>hbase.hregion.majorcompaction</code>参数的值加上或减去<code>hbase.hregion.majorcompaction</code>参数的值乘以一个随机分数的值就确定下一次大合并的时间区间。</p><p>可以通过<code>hbase.hregion.majorcompaction</code>设置为0来禁用major compaction。</p><h2 id="Client-Server交互逻辑">4.2 Client-Server交互逻辑</h2><ol><li>客户端首先会根据配置文件中zookeeper地址连接zookeeper，并读取/&lt;hbase-rootdir&gt;/meta-region-server节点信息，该节点信息存储HBase元数据（hbase:meta）表所在的RegionServer地址以及访问端口等信息。用户可以通过zookeeper命令(get /&lt;hbase-rootdir&gt;/meta-region-server)查看该节点信息。</li><li>根据hbase:meta所在RegionServer的访问信息，客户端会将该元数据表加载到本地并进行缓存。然后在表中确定待检索rowkey所在的RegionServer信息。</li><li>根据数据所在RegionServer的访问信息，客户端会向该RegionServer发送真正的数据读取请求。服务器端接收到该请求之后需要进行复杂的处理，具体的处理流程将会是这个专题的重点。</li></ol><blockquote><ol><li>客户端只需要配置zookeeper的访问地址以及根目录，就可以进行正常的读写请求。不需要配置集群的RegionServer地址列表。</li><li>客户端会将hbase:meta元数据表缓存在本地，因此上述步骤中前两步只会在客户端第一次请求的时候发生，之后所有请求都直接从缓存中加载元数据。如果集群发生某些变化导致hbase:meta元数据更改，客户端再根据本地元数据表请求的时候就会发生异常，此时客户端需要重新加载一份最新的元数据表到本地。</li></ol></blockquote><p><strong>region寻址步骤</strong>：</p><blockquote><ol><li>Client向zookeeper获取存储元数据的 hbass:meta 表 所在的 RegionServer A</li><li>连接 RegionServer A，将habse:meta表缓存到本地，根据rowKey获取region，根据region获取存取该region的 RegionServer B</li></ol></blockquote><h2 id="Hbase写流程">4.3 Hbase写流程</h2><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201111192308660.png" alt="image-20201111192308660"></p><ol><li>Client进行region寻址得到ReionServer的信息</li><li>Client连接RegionServer并发起 put请求</li><li>写入WHL，写入HLog,写入MemStore中</li><li>向Client反馈信息</li><li>判断MemSrore中的量是否达到 <code>flush成为一个StoreFile</code> 的阈值</li></ol><p><strong>写入Hlog的目的</strong>：</p><p>在这个过程中系统会在Zookeeper中记录一个checkpoint，表示这个时刻之前的更新已经持久化了，当系统出现意外时，可能导致MemStore中的数据丢失，此时使用HLog来恢复chckpoint之后的数据。</p><p><strong><em>在对HBase进行写操作的时候，进行Put和Update操作的时候，其实是新增了一条数据，即使是在进行Delete操作的时候，也是新增一条数据，只是这条数据没有value，类型为DELETE，这条数据叫做墓碑标记（Tobstone）。数据的真正删除是在compact操作时进行的。</em></strong></p><h2 id="Hbase读流程">4.4 Hbase读流程</h2><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201111192732741.png" alt="image-20201111192732741"></p><ol><li>Client进行region寻址得到ReionServer的信息</li><li>Client连接RegionServer并发起 get 请求</li><li>先从<code>BlockCache</code>中查找数据，找不到再去<code>MemStore</code>和<code>StoreFile</code>中查询数据</li></ol><h2 id="RegionServer故障恢复">4.5 RegionServer故障恢复</h2><p>心跳机制：</p><blockquote><p>在Zookeeper中保存着RegionServer的相关信息，在RegionServer启动的时候，会在Zookeeper中创建对应的<strong>临时节点</strong>。RegionServer通过Socket和Zookeeper建立session会话，<strong>RegionServer会周期性的向Zookeeper发送ping消息包</strong>，以此说明自己还处于存活状态。而Zookeeper收到ping包后，则会更新对应Session的超时时间。</p><p>当Zookeeper session超时时间还未收到RegionServer的ping包，则Zookeeper会认为该RegionServer出现故障，Zookeeper会将该RegionServer对应的临时节点删除出，并通知Master，Master收到RegionServer挂掉的信息后就会启动数据恢复流程。</p></blockquote><h1 id="参考">5 参考</h1><ol><li><p><a href="https://cloud.tencent.com/developer/article/1530063">Hbase 入门知识点总结</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/69231610">HBase快速入门</a></p></li><li><p><a href="https://www.hellodemos.com/hello-hbase/hbase-5.html">HBase 的行、列模型</a></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java Class类</title>
      <link href="/2020/11/15/java%20Class%E7%B1%BB/"/>
      <url>/2020/11/15/java%20Class%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">1 简介</h1><p>Java中，无论生成某个类的多少个对象，这些对象都会对应于同一个Class对象，这个Class对象是由JVM生成的，通过它能够获悉整个类的结构。要想使用反射，首先需要获得待操作的类所对应的Class对象。</p><p>Class类表示正在运行的Java应用程序中的类和对象，用来保存运行时类型标识（属于那个类)的类</p><pre><code>java运行时系统一直对所有的对象进行所谓的运行时类型标识。这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。</code></pre><blockquote><ol><li>不能显示声明一个Class对象，在加载类时虚拟机自动创建，通过调用类加载器的defineClass方法。</li><li>jvm为每个类型都管理一个独一无二的Class对象。</li><li>没有公共构造函数</li><li>基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。<br>每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。</li></ol></blockquote><h1 id="得到-Class对象的三种方法">2 得到 Class对象的三种方法</h1><blockquote><ol><li><p>调用Object类的getClass()方法<br>MyObject x;<br>Class c1 = x.getClass();</p></li><li><p>使用Class类的中静态forName()方法获得与字符串对应的Class对象。例如：<br>Class.forName(“MyObject”)</p></li><li><p>获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。例如<br>Class cl1 = Manager.class;<br>Class cl2 = int.class;<br>Class cl3 = Double[].class;<br>注意：Class对象实际上描述的只是类型，而这类型未必是类或者接口。例如上面的int.class是一个Class类型的对象。由于历史原因，数组类型的getName方法会返回奇怪的名字。</p></li></ol></blockquote><h1 id="总结">3 总结</h1><ol><li><p>掌握常用的方法，  <code>getClassLoader</code>, <code>getName</code>, <code>newInstance</code>, <code>forName，getFileds,getDeclaredFields等</code>, </p></li><li><p>掌握 <code>Class.forName(className).getInstance()</code>与 <code>new class</code> 的区别与实际中的应用。</p></li></ol><blockquote><ol><li>forName和newInstance结合起来使用，可以根据存储在字符串中的类名创建对象。例如<br>Object obj = Class.forName(s).newInstance();</li><li><strong>forName()就是装载类用的</strong></li><li><strong>jvm在装载类时会执行类的静态代码段，静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了，而且以后不会再执行这段静态代码了。Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。</strong></li><li><strong>使用 newInstance()方法就必须 保证 （1. 这个类已经加载， 2. 这个类已经连接， 这两个恰恰是 <code>forName()</code>做的)</strong></li><li>newInstance: 弱类型。低效率。只能调用无参构造。 </li><li>new: 强类型。相对高效。能调用任何public构造</li></ol></blockquote><ol start="3"><li>getFields()方法与getDeclaredFields()方法的区别(Class.getMethod()与getDeclaredMethod()等同理)</li></ol><blockquote><p>相同点 ：getFields()方法和getDeclaredFields()方法都是获取类的属性;</p><p>不通点：getField()是获取的类的public声明的属性，包括集成而来的public修饰的属性；</p><p>getDeclaredFields()获取的是当前类声明的所有属性，包括private ，protect，public ，但是不包括集成自父类的属性</p></blockquote><h1 id="参考">4 参考</h1><p><a href="https://blog.csdn.net/fengyuzhengfan/article/details/38086743">java class 类参考</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1115_402_移掉k位数字</title>
      <link href="/2020/11/15/daily-leetcode-2020-1115-402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
      <url>/2020/11/15/daily-leetcode-2020-1115-402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:</p><p>num 的长度小于 10002 且 ≥ k。<br>num 不会包含任何前导零。</p><pre><code>输入: num = "1432219", k = 3输出: "1219"解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。输入: num = "10200", k = 1输出: "200"解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。输入: num = "10", k = 2输出: "0"解释: 从原数字移除所有的数字，剩余为空就是0。</code></pre><h1 id="题解">2 题解</h1><p>很明显的一个贪心问题，关键点在于我们呢如何去选择这k个数。我们需要剩下的数字尽可能小，那么就得是高位得数字尽量小，也就是字符串前面得数字尽量小。那么策略来了。对于num, 只要<code>num[i] &gt; num[i+1]</code>，<code>num[i]</code>就是我们要删除得那个。比如<code>45879</code>,当k=1时，删除8得到<code>4579</code>是最有得，这就是所贪的地方。</p><p>我们每次删除一个串然后在去寻找下一个，删除串得到新串，要么太耗时要么太要么太耗内存(取决于是原地操作，还是返回新对象)，这时我们可以考虑考虑利用栈，而维护一个单调栈恰恰和上面的贪心策略一样。</p><ul><li><p>遍历num,对于当前元素val,如果小于栈顶元素，将栈顶元素出栈，k递减,然后将该元素入栈。</p></li><li><p>当k=0时，说明已经删除完了，将num中剩下的入栈，然后将栈倒序连接起来返回就是。</p></li><li><p>当num遍历完时，k&gt;0,说明还得删除一些，那么现在栈式一个单调栈，只需进行k次出栈操作即可，最后将栈倒序连接起来返回。</p></li><li><p>关于去除前导0,前导0是怎么加入的？<code>栈位空且当前元素位0</code>的情况下入栈的，那么我们取个逆好了，<code>栈不为空或当前元素不位0</code></p></li></ul><h1 id="代码">3 代码</h1><p>下面得代码参考了官方题解：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeKdigits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> str<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> num <span class="token keyword">is</span> None <span class="token operator">or</span> len<span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"0"</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> num        <span class="token triple-quoted-string string">""" 构建单调栈 """</span>        num_stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> val <span class="token keyword">in</span> num<span class="token punctuation">:</span>            <span class="token keyword">while</span> k <span class="token operator">and</span> num_stack <span class="token operator">and</span> num_stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> val<span class="token punctuation">:</span>                num_stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                k <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token triple-quoted-string string">""" 去除前导0 """</span>            <span class="token keyword">if</span> val <span class="token operator">!=</span> <span class="token string">'0'</span> <span class="token operator">or</span> num_stack<span class="token punctuation">:</span>                num_stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>        <span class="token triple-quoted-string string">""" 如果去除的还不够， 去除单调栈的后面的 """</span>        res <span class="token operator">=</span> num_stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token keyword">if</span> k <span class="token keyword">else</span> num_stack        <span class="token triple-quoted-string string">""" or ”0“ 的原因，测试用例10，1 """</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token string">"0"</span>    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        num <span class="token operator">=</span> <span class="token string">"10"</span>        k <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>removeKdigits<span class="token punctuation">(</span>num<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    solution<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1114_1122._数组的相对排序</title>
      <link href="/2020/11/14/daily-leetcode-2020-1114-1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/11/14/daily-leetcode-2020-1114-1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>给你两个数组，arr1 和 arr2，</p><p>arr2 中的元素各不相同<br>arr2 中的每个元素都出现在 arr1 中<br>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p><pre><code>输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19]提示arr1.length, arr2.length &lt;= 10000 &lt;= arr1[i], arr2[i] &lt;= 1000arr2&nbsp;中的元素&nbsp;arr2[i]&nbsp;各不相同arr2 中的每个元素&nbsp;arr2[i]&nbsp;都出现在&nbsp;arr1&nbsp;中</code></pre><h1 id="双指针">2 双指针</h1><p>此题的双指针实际上就是一种暴力手段，由于arr2中的元素是不重复的，所以在遍历arr2(arr2_point)时对于当前元素x, 当它在arr1中出现，就把它移到arr1前面(这个位置用arr1_point)，然后arr_point向前移动一位，</p><pre class=" language-python"><code class="language-python">   <span class="token keyword">def</span> <span class="token function">relativeSortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">""" 双指针 """</span>        arr1_len <span class="token operator">=</span> len<span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>        arr2_len <span class="token operator">=</span> len<span class="token punctuation">(</span>arr2<span class="token punctuation">)</span>        arr1_point <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># arr1指针</span>        <span class="token keyword">for</span> arr2_point <span class="token keyword">in</span> range<span class="token punctuation">(</span>arr2_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>arr1_point<span class="token punctuation">,</span> arr1_len<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> arr2<span class="token punctuation">[</span>arr2_point<span class="token punctuation">]</span><span class="token punctuation">:</span>                    arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr1<span class="token punctuation">[</span>arr1_point<span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span class="token punctuation">[</span>arr1_point<span class="token punctuation">]</span><span class="token punctuation">,</span> arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    arr1_point <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token triple-quoted-string string">""" arr1剩下的排序 """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>arr1_point<span class="token punctuation">,</span> arr1_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>arr1_point<span class="token punctuation">,</span> arr1_len<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># print(arr1)</span>        <span class="token keyword">return</span> arr1</code></pre><h1 id="自定义排序">3 自定义排序</h1><p>自定义排序意味着我们只需要设计好排序函数就可以了。</p><p>在排序函数中，问题的关键在于：</p><ol><li>对对arr2中的那些数在arr1中怎么区分大小</li><li>如何区分arr1中在arr2中出现的和没有出现的 大小</li></ol><p>对于第一个问题，很容易想到返回该元素在arr2中的下标不就好了，这意味这我们需要对arr2构造一个map, 对元素x,x-&gt;index.</p><p>第二个问题，我们可以考虑将arr2的元素整体缩小，那么我们就在构造字典的时候用下标除arr2的长，那么肯定是0-1之间，保证了和arr1的大小区分。</p><p>代码：</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">diy_sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">:</span>        arr2_len <span class="token operator">=</span> len<span class="token punctuation">(</span>arr2<span class="token punctuation">)</span>        arr2_map <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;val: index/arr2_len for index, val in enumerate(arr2)&amp;#125;</span>        <span class="token keyword">def</span> <span class="token function">get_val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> arr2_map<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">if</span> x <span class="token keyword">in</span> arr2_map <span class="token keyword">else</span> x        arr1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span>get_val<span class="token punctuation">)</span>        <span class="token keyword">return</span> arr1</code></pre><h1 id="计数排序">4 计数排序</h1><p>由于元素的范围在[0,1000], 可以使用一个数组<code>freq</code> 来存储arr1中每个元素的出现次数。当我们遍历arr2时，对于元素<code>x</code>,我们向<code>res</code>中加入<code>freq[x]</code>个x。当遍历完arr2时，<code>res</code>中得数已经是根据arr2中得元素排好序的；最后，我们将arr1中没有在arr2中出现的数都加入<code>res</code>中，返回<code>res</code>.</p><p>代码：</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">count_sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token triple-quoted-string string">""" 实际上我们可以开小一点的 """</span>        max_value <span class="token operator">=</span> max<span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>        freq <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max_value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token triple-quoted-string string">""" 统计arr1 元素的 freq """</span>        <span class="token keyword">for</span> val <span class="token keyword">in</span> arr1<span class="token punctuation">:</span>            freq<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token triple-quoted-string string">""" 遍历 arr2, 将其在 arr1 中出现的加入 res """</span>        <span class="token keyword">for</span> val <span class="token keyword">in</span> arr2<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">*</span> freq<span class="token punctuation">[</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>            freq<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 将出现的mark掉，后面还要对没有出现的排序</span>        <span class="token triple-quoted-string string">""" 将arr1 中剩下的 加入到res """</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>max_value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> freq<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">*</span> freq<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1113_328_奇偶链表</title>
      <link href="/2020/11/13/daily-leetcode-2020-1113-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/11/13/daily-leetcode-2020-1113-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</code></pre><h1 id="图解">2 图解</h1><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201113135756939.png" alt="image-20201113135756939"></p><h1 id="代码">3 代码</h1><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        even_head<span class="token punctuation">,</span> odd_head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head        <span class="token triple-quoted-string string">""" 将偶数链的头保存起来，待会要拼接到奇数末尾 """</span>        tmp <span class="token operator">=</span> even_head        <span class="token keyword">while</span> even_head <span class="token operator">and</span> even_head<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            odd_head<span class="token punctuation">.</span>next <span class="token operator">=</span> even_head<span class="token punctuation">.</span>next            odd_head <span class="token operator">=</span> odd_head<span class="token punctuation">.</span>next            even_head<span class="token punctuation">.</span>next <span class="token operator">=</span> odd_head<span class="token punctuation">.</span>next            even_head <span class="token operator">=</span> even_head<span class="token punctuation">.</span>next        odd_head<span class="token punctuation">.</span>next <span class="token operator">=</span> tmp        <span class="token keyword">return</span> head</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Levenshtein</title>
      <link href="/2020/11/12/Levenshtein/"/>
      <url>/2020/11/12/Levenshtein/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">1 简介</h1><p>编辑距离,也叫莱文斯坦距离(Levenshtein),是针对二个字符串例如英文字的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。</p><p>三种转换方式：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><h1 id="分析">2 分析</h1><p>对于两个字符串str1和str2，一共有六种操作：</p><ol><li>对str1 插入一个字符，对str2删除一个字符</li><li>对str1删除一个字符，对str2插入一个字符</li><li>对str1替换一个字符，对str2替换一个字符</li></ol><p><em>实际上只有三种操作</em>  不难看出上述六种操作种，成对出现的操作结果是一样的，只需要选一个就可以，例如1中，假设str1位hllo,str2为hello,则对str1插入e变为hello与str2删除e变为hllo是等价的，其他两种情况类似。</p><p>总结下来就是：</p><ol><li>对str1 插入一个字符</li><li>对str2插入一个字符</li><li>修改str1的一个字符</li></ol><h1 id="转移方程">3 转移方程</h1><p>假设我们现在知道了str1的字串sub_str1 hll 到 str2的字串 sub_str2 he的编辑距离, 那么</p><ol><li>假设我们经过k次操作后sub_str1 变为了h, sub_str2为 he, 那么这时只需经过一步操作 <code>sub_str1加一个e</code>就可以将两个变为相同的字符串</li><li>假设我们经过k次操作后sub_str1变为了hle, sub_str2为he，那么这时只需经过一步操作 <code>sub_str2中间插入l</code>就可以使得两个字符相同。</li><li>假设我们经过k次操作后sub_str1变为了hl，sub_str2为he , 那么这时只需一步操作<code>替换sub_str1的l为e</code>就可以使得两个字符相同</li></ol><p>从这里我们可以看出经过次操作，下一步的编辑距离和上一次的相关，不管是对str1插入、str2插入还是str1替换，在多一步操作便可以得到这一次的状态。</p><p>好了，既然是和上一步的状态有关，那么我们该考虑动态规划了。</p><p>设 <code>D[i][j]</code> 表示 str1 的前 <code>i</code> 个字母和 str2 的前 <code>j</code> 个字母之间的编辑距离。</p><p><strong>下面是重点</strong></p><p>对于<code>D[i][j]</code>,变为它的方式无非就三种：</p><ol><li><p>由str1插入一个字符得到。那么此时应该是<code>D[i][j-1]</code>【我们现在匹配的是str2中第j个，前面我们已经匹配好它的前j-1个，即<code>D[i][j-1]</code>,现在在给str1插入一个字符，使得和str2的第j个相等，故<code>D[i][j] = D[i][j-1]+1)</code>】</p></li><li><p>由str2插入一个字符得到。那么此时应该是<code>D[i-1][j]</code>【我们现在匹配的是str1中第i个，前面我们已经匹配好它的前i-1个，即<code>D[i-1][j]</code>,现在在给str2插入一个字符，使得和str1的第i个相等，故<code>D[i][j] = D[i-1][j]+1)</code>】</p></li><li><p>由str1修改一个字符得到。那么此时 应该是<code>D[i-1][j-1]</code>【现在问题是str1前i-1个和str2前j-1个匹配好了，即<code>D[i-1][j-1]</code>, 但是呢现在的问题是str1第i个和str2第j个字符不相等。怎么办，修改str1第i个为str2第j个不就好了。故<code>D[i][j] = D[i-1][j-1]+1)</code>】。但是呢str1第i个字符可能和str2第j个字符相等，那么这时<code>D[i][j] = D[i-1][j-1])</code></p></li></ol><p>也就是，<code>D[i][j]</code>可能来自三中状态，那既然是求最优，min一下就好了。</p><p><code>D[i][j] = min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1]) + (1 if str[i]==str[j])</code></p><h1 id="源码">4 源码</h1><h2 id="dp1">4.1 dp1</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">levenshtein</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    计算 str1 与 str2 的 levenshtein distance    :param str1: str    :param str2: str    :return:  a number, int    """</span>    str1_len <span class="token operator">=</span> len<span class="token punctuation">(</span>str1<span class="token punctuation">)</span>    str2_len <span class="token operator">=</span> len<span class="token punctuation">(</span>str2<span class="token punctuation">)</span>    <span class="token triple-quoted-string string">""" 有一个str 为空 """</span>    <span class="token keyword">if</span> str1_len <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> str2_len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> str1_len <span class="token operator">+</span> str2_len    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>str2_len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>str1_len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token triple-quoted-string string">""" init dp """</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>str1_len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>str2_len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> str1_len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> str2_len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            str1_add <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>            str2_add <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>            str1_rpc <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> str1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> str2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>str1_add<span class="token punctuation">,</span> str2_add<span class="token punctuation">,</span> str1_rpc<span class="token punctuation">)</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>str1_len<span class="token punctuation">]</span><span class="token punctuation">[</span>str2_len<span class="token punctuation">]</span></code></pre><h2 id="dp2">4.2 dp2</h2><p><code>D[i][j] = min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1]) + (1 if str[i]==str[j])</code></p><p>从状态转移方程中可以看出，<code>D[i][j]</code>只和三个量有关，但是我们开辟了一个n*m的list, 那么问题来了，可以在空间上优化吗？解决办法来了，我们只需开辟一个m维的list的就可以了，来表示原先二维数组中的列的个数，即存放一行的值。在迭代的过程中，一行一行计算，利用这一次算出来的数据，将数组覆盖掉，即将这一行的结果存放进数组，然后计算下一行，以此类推，直到最后一行。</p><p>计算当前 d[j]是，实际上d[j]前面存放的相当于原先二维数组中中的<code>d[i][0],d[i][1],...,d[i][j-1]</code>,从d[j]到d[m-1]存放的是</p><p><code>d[i-1][j],d[i-1][j+1],...,d[i-1],d[m-1]</code>,只是其左上的元素没有记录下来，那么我们用一个变量来保存它就可以了。</p><p>画图解释起来可能比较好，但比较麻烦，如果你还没有听懂，那么我建议你画个图就秒懂。</p><p>具体代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">levenshtein2</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    计算 str1 与 str2 的 levenshtein distance    :param str1: str    :param str2: str    :return:  a number, int    """</span>    str1_len <span class="token operator">=</span> len<span class="token punctuation">(</span>str1<span class="token punctuation">)</span>    str2_len <span class="token operator">=</span> len<span class="token punctuation">(</span>str2<span class="token punctuation">)</span>    <span class="token triple-quoted-string string">""" 有一个str 为空 """</span>    <span class="token keyword">if</span> str1_len <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> str2_len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> str1_len <span class="token operator">+</span> str2_len    dp <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>str2_len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>str1_len<span class="token punctuation">)</span><span class="token punctuation">:</span>        str1_rpc <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> str2_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> str1_rpc <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> str1_rpc <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> str2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">else</span> str1_rpc<span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>                j<span class="token punctuation">]</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><h2 id="dp3">4.3 dp3</h2><p>根据dp3我们知道了，可以节约空间，那么问题来了，可不可以进一步呢，答案是肯定的。</p><p>例如我们现在有str1长度为2，str2长度为10000,那么按照dp2的代码，我们需要开辟一个10001的数组(python中为list), 那么如果我们交换一下str1和str2不就好了，开辟一个长度为3 的数组就可以了。同时时间复杂是不变的，都是两层循环，复杂度都是n*m.</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">levenshtein3</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>str1<span class="token punctuation">)</span> <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">:</span>        str1<span class="token punctuation">,</span> str2 <span class="token operator">=</span> str2<span class="token punctuation">,</span> str1    <span class="token keyword">return</span> levenshtein2<span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span></code></pre><pre><code>str1 = "1f"str2 = "execution"</code></pre><p>得到的结果如下：</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201113091659223.png" alt="image-20201113091659223"></p><h1 id="文本相似度">5 文本相似度</h1><p>编辑距离算法被数据科学家广泛应用，是用作机器翻译和语音识别评价标准的基本算法</p><p>公式如下；</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201113092248470.png" alt="image-20201113092248470"></p><p>ED(A,B)表示的是A，B两个句子之间的编辑距离。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">similarity_levenshtein</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    利用 levenshtein 距离计算两个句子相似度    :param str1:    :param str2:    :return:  a double, 0-1    """</span>    max_len <span class="token operator">=</span> max<span class="token punctuation">(</span>len<span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">-</span> levenshtein3<span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span> <span class="token operator">/</span> max_len</code></pre><ol><li><p>编辑距离对于短文本来说速度还可以，但是当文本太长时速度便不是很理想了</p></li><li><p>同时编辑距离只是从字面来计算相似度，对于歧义性、和多词一义这种毫无表征可言，简单来说就是无法从抽象出主题。</p></li><li><p>编辑距离相对于词嵌入，以wordvec来说，省去了分词、停用词处理等。</p></li><li><p>相对于tf-idf,后面再探讨</p></li><li><p>如今在这个bert横行的时代，我举得它的适用范围是<code>脱敏数据</code>，步骤简单，不需要太大的计算力，没有复杂的处理。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1112_922_按奇偶排序数组2</title>
      <link href="/2020/11/12/daily-leetcode-2020-1112-922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/"/>
      <url>/2020/11/12/daily-leetcode-2020-1112-922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p><p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p><p>你可以返回任何满足上述条件的数组作为答案。</p><pre><code>输入：[4,2,5,7]输出：[4,5,2,7]解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。提示2 &lt;= A.length &lt;= 20000A.length % 2 == 00 &lt;= A[i] &lt;= 1000</code></pre><h1 id="题解">2 题解</h1><p>数组肯定是偶数长，当出现奇偶不配，肯定是成对的出现，例如有3个奇数在偶数位的，肯定会有3个偶数在奇数位的。</p><p>很明显的一个双指针问题。</p><h2 id="双指针">2.1 双指针</h2><p>维护两个指针i和j，i从前面开始扫描，寻找奇数在偶数位的，j逆向扫描，寻找偶数在奇数位的，swap.</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArrayByParityII</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">:</span>        nums_len <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nums_len <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> nums_len <span class="token operator">and</span> j <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">""" 奇数在偶数位 """</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> nums_len<span class="token punctuation">:</span>                <span class="token keyword">if</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">and</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token triple-quoted-string string">""" 偶数在奇数位 """</span>            <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span> j <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                j <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> i <span class="token operator">&lt;</span> nums_len <span class="token operator">and</span> j <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> A    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>sortArrayByParityII<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    solution<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>改进</strong>：</p><p>在前面中我们呢每次下标都是跳一步，实际上一个奇数它的下一个连续奇数得跳两步，偶数也是</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">sortArrayByParityII</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">:</span>        nums_len <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nums_len <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> nums_len <span class="token operator">and</span> j <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">""" 奇数在偶数位 """</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> nums_len<span class="token punctuation">:</span>                <span class="token keyword">if</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                i <span class="token operator">+=</span> <span class="token number">2</span>            <span class="token triple-quoted-string string">""" 偶数在奇数位 """</span>            <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token operator">not</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                j <span class="token operator">-=</span> <span class="token number">2</span>            <span class="token keyword">if</span> i <span class="token operator">&lt;</span> nums_len <span class="token operator">and</span> j <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> A</code></pre><h2 id="空间换时间">2.2 空间换时间</h2><p>我们可以开辟一个len(A)的list,不修改原数组，遇见偶数放偶数位，遇见奇数放奇数位。</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">method2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        odd_index <span class="token operator">=</span> <span class="token number">1</span>        even_index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> val <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> val <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                res<span class="token punctuation">[</span>odd_index<span class="token punctuation">]</span> <span class="token operator">=</span> val                odd_index <span class="token operator">+=</span> <span class="token number">2</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">[</span>even_index<span class="token punctuation">]</span> <span class="token operator">=</span> val                even_index <span class="token operator">+=</span> <span class="token number">2</span>        <span class="token keyword">return</span> res</code></pre><h2 id="python那些骚操作">2.3 python那些骚操作</h2><p>空间和时间效率都很低，重点在于掌握，<code>zip、reduce</code>函数得使用。</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">method3</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        odd <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> nums <span class="token keyword">if</span> i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span>        even <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> nums <span class="token keyword">if</span> <span class="token operator">not</span> i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">from</span> functools <span class="token keyword">import</span> reduce        <span class="token keyword">return</span> reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token keyword">in</span> zip<span class="token punctuation">(</span>even<span class="token punctuation">,</span> odd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h1 id="其他">3 其他</h1><p> <a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">922. 按奇偶排序数组 II</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020-1111-514_自由之路</title>
      <link href="/2020/11/11/daily-leetcode-2020-1111-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"/>
      <url>/2020/11/11/daily-leetcode-2020-1111-514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。</p><p>给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。</p><p>最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。</p><p>旋转 ring 拼出 key 字符 key[i] 的阶段中：</p><p>您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。<br>如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。</p><pre><code>输入: ring = "godding", key = "gd"输出: 4解释: 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。  对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring "godding" 2步使它变成 "ddinggo"。 当然, 我们还需要1步进行拼写。 因此最终的输出是 4。提示ring 和&nbsp;key&nbsp;的字符串长度取值范围均为&nbsp;1 至&nbsp;100；两个字符串中都只有小写字符，并且均可能存在重复字符；字符串&nbsp;key&nbsp;一定可以由字符串 ring&nbsp;旋转拼出。</code></pre><h1 id="题解">2 题解</h1><h2 id="贪心">2.1 贪心</h2><p>首先拿到这个题后，感觉利用贪心算法可以解决，于是乎写出了如下的代码：</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">my_method</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ring<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        ring_len <span class="token operator">=</span> len<span class="token punctuation">(</span>ring<span class="token punctuation">)</span>        key_len <span class="token operator">=</span> len<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        distance <span class="token operator">=</span> ring_len  <span class="token comment" spellcheck="true"># init distance， 记录一轮 转 的最优 距离</span>        nearest_index <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 保留一轮 转 中 的 ring中的index</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>key_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>ring_len<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token triple-quoted-string string">""" 找到一个匹配的"""</span>                <span class="token keyword">if</span> ring<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token triple-quoted-string string">""" 选择正向转还是逆向转 """</span>                    new_distance <span class="token operator">=</span> min<span class="token punctuation">(</span>index<span class="token punctuation">,</span> ring_len <span class="token operator">-</span> index<span class="token punctuation">)</span>                    <span class="token triple-quoted-string string">""" 更新distance, nearest_index """</span>                    <span class="token keyword">if</span> new_distance <span class="token operator">&lt;</span> distance<span class="token punctuation">:</span>                        distance <span class="token operator">=</span> new_distance                        nearest_index <span class="token operator">=</span> index                    <span class="token comment" spellcheck="true"># if new_distance == distance:</span>                    <span class="token comment" spellcheck="true">#     return min(self.my_method(ring[nearest_index:] + ring[:nearest_index], key[k:]),</span>                    <span class="token comment" spellcheck="true">#                self.my_method(ring[distance:] + ring[:distance], key[k:]))</span>            <span class="token triple-quoted-string string">""" 按中心按钮 """</span>            res <span class="token operator">+=</span> distance <span class="token operator">+</span> <span class="token number">1</span>            <span class="token triple-quoted-string string">""" 更新 ring, distance, nearest_index """</span>            ring <span class="token operator">=</span> ring<span class="token punctuation">[</span>nearest_index<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> ring<span class="token punctuation">[</span><span class="token punctuation">:</span>nearest_index<span class="token punctuation">]</span>            distance<span class="token punctuation">,</span> nearest_index <span class="token operator">=</span> ring_len<span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">return</span> res</code></pre><p>然后发现wa。后来仔细想了一下，是这么回事：</p><pre><code>"""那么问题来了，这是一种基于贪心的算法，每一次保证一轮中是最优的，但是在这一轮进行完后改变了 ring， 影响了后面的每一轮，这就要求全局最优。而贪心只保证了局部最优例如测试用例：ring="nyngl" key="yyynnnnnnlllggg"就没过。也就是说当 距离相等的时候该做如何选择， 如 yngln ， 我们下一个 需要匹配的是 n ， 是逆转为nglny 还是正转为nyngl"""</code></pre><p>后续又添加了条件，当相等的时候，也就是上面注释的代码，但是递归太深，导致栈溢出。</p><h2 id="递归">2.2 递归</h2><p>下面代码参考leetcode评论区大佬<a href="https://leetcode-cn.com/u/fa-kuang-de-jie-zi/">发狂的橘子</a>，用到了python的缓存机制。</p><p>这个方法非常巧妙地简化了当ring中存在多个与key某一位匹配时的选择问题。 </p><blockquote><p>str.find(s)是找s在str中最靠左边的下标</p><p>str.rfind(s)是找s在str中最靠右边的下标。</p></blockquote><p>不论这一刻有多少个匹配的，但你转的方式只有两种。将此轮所有匹配的（包括一个）简化为两种旋转方式。</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">findRotateSteps</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ring<span class="token punctuation">:</span> str<span class="token punctuation">,</span> key<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        key_len <span class="token operator">=</span> len<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">import</span> functools        @functools<span class="token punctuation">.</span>lru_cache<span class="token punctuation">(</span>None<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> key_len<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token number">0</span>            left_index <span class="token operator">=</span> s<span class="token punctuation">.</span>find<span class="token punctuation">(</span>key<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>            right_index <span class="token operator">=</span> s<span class="token punctuation">.</span>rfind<span class="token punctuation">(</span>key<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> min<span class="token punctuation">(</span>left_index <span class="token operator">+</span> helper<span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>left_index<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span>left_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                      len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> right_index <span class="token operator">+</span> helper<span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>right_index<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span>right_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">return</span> res        <span class="token keyword">return</span> helper<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ring<span class="token punctuation">)</span></code></pre><h2 id="动态规划">2.3 动态规划</h2><p>用一个n*m的的数组，<code>dp[i][j]</code>表示第key中前i个字符对齐后，ring中第j个字符转到12点位需要的最少次数(逆时针或者顺时针转)，</p><p>现在问题是 当前 <code>i-1</code>个字符对齐时，如何求第i个字符对齐</p><p>在下图中，整条线代表的ring这个序列，在上一轮中，我们在ring中找到了与key中第i-1个匹配的字符<code>index=k</code>（最优），并将它移动了12点位。</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/spark/image-20201111231208935.png" alt="image-20201111231208935"></p><p><strong>此轮中，我们在ring中找到了一个与key中第i个字符匹配的字符<code>index=j</code>，那么我们只需要计算将<code>index=j</code>转到<code>index=k</code>的的最少次数（index=j在上一轮操作中已经转到了12点位，现在index=j就是12点位), 然后再加上上一次已经计算出来的不就是这次的嘛。</strong></p><p><code>dp[i][j] = dp[i - 1][k] + dist</code>,dist为 <code>index=j</code>转到<code>index=k</code>的的最少次数。</p><p>转的方式无非两种，逆时针和顺时针。</p><ol><li>图中红色线段为<code>index=j</code>逆时针转到<code>index=k</code>的距离，为<code> abs(j-k)</code></li><li>图中两段蓝色线段和为<code>index=j</code>顺时针转到<code>index=k</code>的距离，则距离为<code> ring_len-abs(j-k)</code></li></ol><p>通过上面的分析我们可以得到这样的一个方程</p><p><code>dp[i][j] = dp[i - 1][k] + min(abs(j-k), ring_len-abs(j-k)))</code></p><p><strong>但是在ring中可能存在不止一个满足<code>与key中第i个字符匹配</code>的字符，那就说明我们需要遍历ring（包裹一层循环)，遇到更优的dp[i][j]还要进行更新</strong>。所以，最终的状态转移方程为</p><p><code>dp[i][j] = min(dp[i][j],dp[i - 1][k] + min(abs(j-k), ring_len-abs(j-k))))</code></p><p>代码：</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">dp_method</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ring<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        ring_len <span class="token operator">=</span> len<span class="token punctuation">(</span>ring<span class="token punctuation">)</span>        key_len <span class="token operator">=</span> len<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">10001</span><span class="token punctuation">]</span> <span class="token operator">*</span> ring_len <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>key_len<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># init dp</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>ring_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> ring<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>i<span class="token punctuation">,</span> ring_len <span class="token operator">-</span> i<span class="token punctuation">)</span>        <span class="token keyword">for</span> key_index <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> key_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> ring_index <span class="token keyword">in</span> range<span class="token punctuation">(</span>ring_len<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token triple-quoted-string string">""" 此轮找到了一个匹配的 """</span>                <span class="token keyword">if</span> ring<span class="token punctuation">[</span>ring_index<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">[</span>key_index<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token triple-quoted-string string">""" 包一层循环，在ring中 更新 dp """</span>                    <span class="token keyword">for</span> inner_ring_index <span class="token keyword">in</span> range<span class="token punctuation">(</span>ring_len<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token triple-quoted-string string">""" 在ring中 上一个匹配的 """</span>                        <span class="token keyword">if</span> key<span class="token punctuation">[</span>key_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> ring<span class="token punctuation">[</span>inner_ring_index<span class="token punctuation">]</span><span class="token punctuation">:</span>                            dist <span class="token operator">=</span> abs<span class="token punctuation">(</span>ring_index <span class="token operator">-</span> inner_ring_index<span class="token punctuation">)</span>                            dp<span class="token punctuation">[</span>key_index<span class="token punctuation">]</span><span class="token punctuation">[</span>ring_index<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>key_index<span class="token punctuation">]</span><span class="token punctuation">[</span>ring_index<span class="token punctuation">]</span><span class="token punctuation">,</span>                                                            min<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> ring_len <span class="token operator">-</span> dist<span class="token punctuation">)</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>key_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>                                                                inner_ring_index<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token triple-quoted-string string">"""         最终我们要返回的肯定是key的所有字符都被依次对齐了， 那么结果肯定在dp[key_len-1]中，        min一下其实就是筛选出 在ring中匹配 key最后一个字符 的那个字符到12点位的最短距离        加上 key_len 的原因是前面我们没有在对齐后按中心按钮，一共需要按key_len 次 """</span>        <span class="token keyword">return</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>key_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> key_len</code></pre><h1 id="其他">3 其他</h1><p>原题连接</p><p><a href="https://leetcode-cn.com/problems/freedom-trail/">514. 自由之路</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1105_127_单词接龙</title>
      <link href="/2020/11/10/daily-leetcode-2020-1105-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
      <url>/2020/11/10/daily-leetcode-2020-1105-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:</p><p>如果不存在这样的转换序列，返回 0。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p><pre><code>输入:beginWord = "hit",endWord = "cog",wordList = ["hot","dot","dog","lot","log","cog"]输出: 5解释: 一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog",     返回它的长度 5。输入:beginWord = "hit"endWord = "cog"wordList = ["hot","dot","dog","lot","log"]输出:&nbsp;0解释:&nbsp;endWord "cog" 不在字典中，所以无法进行转换。</code></pre><h1 id="题解">2 题解</h1><p>简单来说就是求图的两点最短路径，每个单词看成一个点，只有相差一个字符的点之间才有路径，路径权值全部为1.</p><h2 id="BFS">2.1 BFS</h2><p>广度优先搜素是最直观的，但是这个超时了。。。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">ladder_length</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> beginWord<span class="token punctuation">:</span> str<span class="token punctuation">,</span> endWord<span class="token punctuation">:</span> str<span class="token punctuation">,</span> wordList<span class="token punctuation">:</span> <span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue        queue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>        wordList_len <span class="token operator">=</span> len<span class="token punctuation">(</span>wordList<span class="token punctuation">)</span>        word_len <span class="token operator">=</span> len<span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span>        <span class="token triple-quoted-string string">""" 用来标记wordList中的元素是否遍历过 """</span>        flag <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>wordList_len<span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">1</span>        queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">can_change</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">"""            判断 str1 和 str2 是否 对应位置只有一位不相等            :param str1:            :param str2:            :return:            """</span>            <span class="token keyword">return</span> sum<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> str1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> str2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>word_len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>        <span class="token keyword">while</span> queue<span class="token punctuation">.</span>not_empty<span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token number">1</span>            size <span class="token operator">=</span> queue<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">while</span> size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                head_str <span class="token operator">=</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>wordList_len<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token triple-quoted-string string">""" 该元素已经遍历过, 跳过 """</span>                    <span class="token keyword">if</span> flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">continue</span>                    val <span class="token operator">=</span> wordList<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    <span class="token triple-quoted-string string">""" 是联通的 """</span>                    <span class="token keyword">if</span> can_change<span class="token punctuation">(</span>head_str<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">if</span> val <span class="token operator">==</span> endWord<span class="token punctuation">:</span>                            <span class="token keyword">return</span> res                        queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>val<span class="token punctuation">)</span>                        flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                size <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># beginWord = "b"</span>        <span class="token comment" spellcheck="true"># endWord = "e"</span>        <span class="token comment" spellcheck="true"># wordList = ["a","e"]</span>        beginWord <span class="token operator">=</span> <span class="token string">"teach"</span>        endWord <span class="token operator">=</span> <span class="token string">"place"</span>        wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"peale"</span><span class="token punctuation">,</span> <span class="token string">"wilts"</span><span class="token punctuation">,</span> <span class="token string">"place"</span><span class="token punctuation">,</span> <span class="token string">"fetch"</span><span class="token punctuation">,</span> <span class="token string">"purer"</span><span class="token punctuation">,</span> <span class="token string">"pooch"</span><span class="token punctuation">,</span> <span class="token string">"peace"</span><span class="token punctuation">,</span> <span class="token string">"poach"</span><span class="token punctuation">,</span> <span class="token string">"berra"</span><span class="token punctuation">,</span> <span class="token string">"teach"</span><span class="token punctuation">,</span> <span class="token string">"rheum"</span><span class="token punctuation">,</span>                    <span class="token string">"peach"</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>ladder_length<span class="token punctuation">(</span>beginWord<span class="token punctuation">,</span> endWord<span class="token punctuation">,</span> wordList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    solution<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="暴力">2.2 暴力</h2><p>别人的一种解法 作者此题评论区 habbi</p><p>思路：每次拿到一个节点时生成所有可能的下一个节点(可联通的)，新生成的节点只要再列表中就参与计算</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> beginWord<span class="token punctuation">:</span> str<span class="token punctuation">,</span> endWord<span class="token punctuation">:</span> str<span class="token punctuation">,</span> wordList<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> endWord <span class="token operator">not</span> <span class="token keyword">in</span> wordList<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>endWord<span class="token punctuation">)</span>        ws <span class="token operator">=</span> set<span class="token punctuation">(</span>wordList<span class="token punctuation">)</span>        head <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;beginWord&amp;#125;</span>        tail <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;endWord&amp;#125;</span>        tmp <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token string">'abcdefghijklmnopqrstuvwxyz'</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> head<span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">></span> len<span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">:</span>                head<span class="token punctuation">,</span> tail <span class="token operator">=</span> tail<span class="token punctuation">,</span> head            q <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> cur <span class="token keyword">in</span> head<span class="token punctuation">:</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> j <span class="token keyword">in</span> tmp<span class="token punctuation">:</span>                        word <span class="token operator">=</span> cur<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> j <span class="token operator">+</span> cur<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> word <span class="token keyword">in</span> tail<span class="token punctuation">:</span>                            <span class="token keyword">return</span> res <span class="token operator">+</span> <span class="token number">1</span>                        <span class="token keyword">if</span> word <span class="token keyword">in</span> ws<span class="token punctuation">:</span>                            q<span class="token punctuation">.</span>add<span class="token punctuation">(</span>word<span class="token punctuation">)</span>                            ws<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>word<span class="token punctuation">)</span>            head <span class="token operator">=</span> q            res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token number">0</span></code></pre><h1 id="总结">3 总结</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统中的A/B测试</title>
      <link href="/2020/11/10/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84A-B%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/11/10/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84A-B%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是A-B测试">1 什么是A/B测试</h1><h1 id>2 </h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1110_31_下一个排列</title>
      <link href="/2020/11/10/daily-leetcode-2020-1110-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
      <url>/2020/11/10/daily-leetcode-2020-1110-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>下面是官方原题描述：</p><blockquote><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p></blockquote><p>如果你没有听懂，那不该是你一个^-^,</p><p><code>翻译</code> 过来就是这样的</p><blockquote><p>找出这个数组排序出的所有数中，刚好比当前数大的那个数，不存在就返回最小的排列</p></blockquote><p>刚拿到题的时候没有思路，后来写了几十行代码才发现思路已经不符合题意了-<code>常数空间</code>,参考了别人的答案；但是发现先很多题解要么太啰嗦要么太书面化，要么给了答案没说 原因，看代码一知半解很是模糊。代码很容易看懂，单解释起来还是有些啰嗦</p><p>下面将非常详细地以大白话的形式从答案推题解——<code>对于每一步的操作说出个所以然</code>,而不是一个抽象的洋洋洒洒很多字讲不明白的，然后再正向推题解。</p><h1 id="从答案推原因">2 从答案推原因</h1><p>先给出这题的答案(唯一):</p><p>存在的情况下：</p><blockquote><ol><li>从后往前遍历，寻找一个 满足 nums[i]&lt; nums[i+1] 一个下标 i，</li><li>从下标 i+1 到 end这段寻找一个数 nums[k]&gt; nums[i](这里也是从后往前遍历)</li><li>交换 nums[k] 与nums[i]</li><li>最后翻转 nums[k+1:]</li></ol></blockquote><p>不存在：</p><blockquote><p>将序列升序排序即可</p></blockquote><p>重点再第一种情况,存在的情况下：</p><ol><li><p>那么问题来了，为什么要从后往前遍历</p><blockquote><p>我们寻找的是比原数大的一个，但是每次希望的是增幅尽量小；要让增幅尽量小，那么就尽量在低位进行操作，尽量保持高位不变。</p></blockquote></li><li><p>为什么要寻找一个 满足 nums[i]&lt; nums[i+1] 一个下标 i？为什么 要 从下标 i+1 到 end这段寻找一个数 nums[k]&gt; nums[i]</p><blockquote><p>找i这个的目的就是寻找一个较小的数，可以看的出这个下标的右边都是降序排序，如果将右边内任意两个数进行swap，那么会比原来变的小，而我们寻找的是比原数大的。比如[1,2,7,4,3,1],我们进行第一步后，寻找到的下标为1，对应的值nums[1] = 2, 2右边任意两个数进行swap会比原来变的小</p><p>找到i后我们去在i的右边找一个刚刚好比nums[i]大的这个数，这个数比nums[i]大，但只好刚刚大一点，也就是说在大的情况下尽量小。</p><p>较小的数在前面，较大数在后面，这样交换后才会比原数大，这就是后面进行交换的原因。</p></blockquote></li><li><p>为什么最后翻转 nums[k+1:]</p><blockquote><p>nums[k+1:]是一个降序，但只有当它是纯升序时，这才更贴近原数(增幅小)</p></blockquote></li></ol><h1 id="正向推题解">3 正向推题解</h1><p>重点理解一下1，2步：</p><p>问题的本质是交换原序列中两个数以及施加可能的排序操作，使得变换后的序列刚刚好比原数大。</p><p>交换序列中两个数的过程中我们尽量要保证高位保持不变，低位进行交换操作，所有倒序遍历势在必行。</p><p>通过交换使得比原数大，那么就得在前面寻找一个 小数，后面寻找一个大数。【大数与小数是两个之间相对来说得】。</p><p>那么问题又来了，这样交换可以使得变大，但是如何交换才能更加贴近原数，以及如何寻找这两个数呢？ 解决办法来了，从后往前遍历，找一个数 small_val 使得这个数得右边是个降序，然后在这个降序序列中又寻找一个刚刚好比small_val 大得数 big_val。交换。交换后将后面部分变为纯升序使得更加贴近原数。</p><hr><h1 id="源码">4 源码</h1><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextPermutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify nums in-place instead.        """</span>        <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>                j <span class="token operator">-=</span> <span class="token number">1</span>        small_index<span class="token punctuation">,</span> big_index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span>        nums_len <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 寻找较小数的下标</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>nums_len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                small_index <span class="token operator">=</span> i                <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># nums本身是一个降序排序， 不存在,对nums进行 原地排序</span>        <span class="token keyword">if</span> small_index <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token comment" spellcheck="true"># 寻找较大 数的下标</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>nums_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> small_index<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>small_index<span class="token punctuation">]</span><span class="token punctuation">:</span>                big_index <span class="token operator">=</span> i                <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># swap</span>        nums<span class="token punctuation">[</span>small_index<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>big_index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>big_index<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>small_index<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 后面进行sort</span>        reverse<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> small_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> nums_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>nextPermutation<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    solution<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="总结">5 总结</h1><p>原题链接：</p><h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><p><a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-powcai/">参考</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetcode_2020_1108_122_买卖股票的最佳时机</title>
      <link href="/2020/11/10/daily-leetcode-2020-1108-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2020/11/10/daily-leetcode-2020-1108-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</p><pre><code>输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&nbsp;    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&nbsp;    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。&nbsp;    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。提示：1 &lt;= prices.length &lt;= 3 * 10 ^ 40 &lt;= prices[i] &lt;= 10 ^ 4</code></pre><h1 id="题目分析">2 题目分析</h1><h2 id="贪心">2.1 贪心</h2><p>因为我们已经有了预知能力，只有明天的价格比今天高，就有利可图，我们就买今天的股票，然后到明天再卖出。则利润为<code>prices[i+1]-prices[i]</code>,到最后一天（以后的那些天价格都没有这一天价格高了，即峰值），我们会将昨天preices[j-1]拥有的股票以今天的价格prices[j]卖出,那么获得的利润<code>prices[j]-prices[j-1]</code>,然后再也不买股票了(<strong>明天的价格比今天高</strong> 这个条件再也不符合了)。</p><p>说人话就是，只要今天的价格比昨天高，你只管往出卖就有钱赚，具体哪一天买卖操那闲心干啥。</p><p>贪心算法在此的本质是吸取正利润区间，也就是今天价格比昨天高的这种小区间</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 贪心</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>                res <span class="token operator">+=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res</code></pre><h2 id="动态规划">2.2 动态规划</h2><p>动态规划的重点在于寻找状态转移方程，那么我们就第i的状态作以分析。</p><p>在第i天，股票的状态有两种，持有和没有。而每种状态小分两个小情况。我们以dp[i][0]来表示持有的状态时的最大利润，dp[i][1]来表示 不持有的状态时的最大利润。</p><ol><li><p>持有</p><blockquote><ol><li><p>昨天就持有，今天没有卖出，</p><p>那么目前的利润是 昨天有的时的最大利润，  dp[i-1][0]</p></li><li><p>昨天没有的，今天新买的</p><p>那么目前的利润是  昨天不持有时的最大利润  - 今天的支出， dp[i-1][1] - prices[i]</p></li></ol></blockquote></li><li><p>不持有</p><blockquote><ol><li><p>昨天就没有，今天也没有买</p><p>那目前的利润就是  昨天没有时的最大利润 ， dp[i-1][1]</p></li><li><p>昨天有的，今天卖掉了</p><p>那目前的利润就是 昨天有时的最大利润 + 今天卖出的 ， dp[i-1][0] + price[i]</p></li></ol></blockquote></li></ol><p>通过上面的分析，我们得到了状态转移方程，那么什么最后的我需要的状态时怎样的，肯定时把手里股票卖干净时的状态。即dp[n][1],</p><p>同时，初始状态应该时怎样的，第1天不持有股票故让dp[0][1]=0, 第一天持有股票则dp[0][0] = - preices[0](即第一天买了股票)</p><p>根据上面的分析，我们可以写处如下的代码：</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">dp_method</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">)</span><span class="token punctuation">:</span>        prices_len <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>prices_len<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># init dp[0]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> prices_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>prices_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre><p>上面的代码种，我们要开辟一个n*2的list，但是实际上我们用四个变量不断覆盖就能完成更新操作，改进的代码如下。</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">dp_method2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp_has<span class="token punctuation">,</span> dp_noHas <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp_has_new <span class="token operator">=</span> max<span class="token punctuation">(</span>dp_has<span class="token punctuation">,</span> dp_noHas <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp_noHas_new <span class="token operator">=</span> max<span class="token punctuation">(</span>dp_noHas<span class="token punctuation">,</span> dp_has <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp_has <span class="token operator">=</span> dp_has_new            dp_noHas <span class="token operator">=</span> dp_noHas_new        <span class="token keyword">return</span> dp_noHas</code></pre><h1 id="总结">3 总结</h1><p>动态规划的关键点在于寻找状态方程，例如 最大礼物和，编辑距离等经典题都是如此，改天抽个时间做个总结</p><p>原题链接:</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily-leetCode-2020-1109-973-最接近原点的k个点</title>
      <link href="/2020/11/09/daily-leetCode-2020-1109-973-%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84k%E4%B8%AA%E7%82%B9/"/>
      <url>/2020/11/09/daily-leetCode-2020-1109-973-%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84k%E4%B8%AA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><p>我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。</p><p>（这里，平面上两点之间的距离是欧几里德距离。）</p><p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p><pre><code>输入：points = [[1,3],[-2,2]], K = 1输出：[[-2,2]]解释： (1, 3) 和原点之间的距离为 sqrt(10)，(-2, 2) 和原点之间的距离为 sqrt(8)，由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。输入：points = [[3,3],[5,-1],[-2,4]], K = 2输出：[[3,3],[-2,4]]（答案 [[-2,4],[3,3]] 也会被接受。）提示1 &lt;= K &lt;= points.length &lt;= 10000-10000 &lt; points[i][0] &lt; 10000-10000 &lt; points[i][1] &lt; 10000</code></pre><h1 id="分析题目">2 分析题目</h1><p>topK问题，排序取前k个。</p><p>优化/简化</p><ol><li>因为计算到原点的距离，所以可以这样写： sqrt(x[0]**2+x[1]**2)</li><li>开平方增加了计算时间，同时还失去精度，所以可以这样写 x[0]**2+x[1]**2</li></ol><h1 id="源码">3 源码</h1><h2 id="优雅的python">3.1 优雅的python</h2><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">kClosest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> points<span class="token punctuation">,</span> K<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">""" method1 """</span>        <span class="token comment" spellcheck="true"># points.sort(key=lambda x: x[0] ** 2 + x[1] ** 2, reverse=False)</span>        <span class="token comment" spellcheck="true"># return points[:K]</span>        <span class="token triple-quoted-string string">""" method 2"""</span>        <span class="token keyword">return</span> sorted<span class="token punctuation">(</span>points<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>K<span class="token punctuation">]</span></code></pre><p>代码已经很清晰了，这里简单说下 <code>sort，sorted</code>的区别，<code>sort</code>是属于list的方法，是原地操作，<code>sorted</code>返回的是一个list，适用于任何可迭代对象。</p><h2 id="快速排序">3.2 快速排序</h2><p>这里可以用快速排序来解决。每次用 快排的<code>partition</code>返回排序用于此轮比较元素的的下标index，这轮比较后：比这个元素大的放其后面，比其小的放前面；当index== K-1时，说明前k个元素已经满足要求；比k-1小时，去index的右边寻找，比k-1大时，去index的左边寻找。</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        快排下标        :param nums:  待排序 list        :param start:  开始下标        :param end:  结束下标        :return:  a number , index        """</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> start<span class="token punctuation">,</span> end        head_dist <span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> end <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> head_dist<span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> j <span class="token operator">></span> start <span class="token operator">and</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">></span> head_dist<span class="token punctuation">:</span>                j <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> j<span class="token punctuation">:</span>                <span class="token keyword">break</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span>        <span class="token keyword">return</span> j    <span class="token keyword">def</span> <span class="token function">quick_sort_k</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :param nums:        :param start:        :param end:        :param k:        :return:        """</span>        index <span class="token operator">=</span> self<span class="token punctuation">.</span>partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span>        <span class="token keyword">if</span> index <span class="token operator">==</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>quick_sort_k<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token keyword">if</span> index <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>quick_sort_k<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span>                                                                                                  index<span class="token number">-1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span></code></pre><h2 id="优先队列">3.3 优先队列</h2><blockquote><p>使用一个优先队列实时维护前 K 个最小的距离平方。</p><p>首先我们将前 K 个点的编号以及对应的距离平方放入优先队列中，随后从第K+1 个点开始遍历：如果当前点的距离平方比堆顶的点的距离平方要小，就把堆顶的点弹出，再插入当前的点。当遍历完成后，所有在优先队列中的点就是前 KK 个距离最小的点。</p></blockquote><pre class=" language-python"><code class="language-python">        <span class="token keyword">import</span> heapq        q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span>x <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">-</span> y <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token punctuation">:</span>K<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>q<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>points<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>K<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            x<span class="token punctuation">,</span> y <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            dist <span class="token operator">=</span> <span class="token operator">-</span>x <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">-</span> y <span class="token operator">**</span> <span class="token number">2</span>            heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token punctuation">(</span>dist<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>        ans <span class="token operator">=</span> <span class="token punctuation">[</span>points<span class="token punctuation">[</span>identity<span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> identity<span class="token punctuation">)</span> <span class="token keyword">in</span> q<span class="token punctuation">]</span>        <span class="token keyword">return</span> ans</code></pre><p><strong>heapq 优先队列为小根堆</strong></p><h1 id="总结">4 总结</h1><blockquote><p>这题和剑指offer40最小的K个数几乎一摸一样，掌握快速排序、优先队列是重点，常规解法并不能使面试官满意。另外用到快排变形的题还有 “找出数组中出现次数超过一半的那个数”</p></blockquote><p>原题链接：</p><h4 id="973-最接近原点的-K-个点"><a href="#973-最接近原点的-K-个点" class="headerlink" title="973. 最接近原点的 K 个点"></a><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">973. 最接近原点的 K 个点</a></h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scala的serializable</title>
      <link href="/2020/11/09/scala%E7%9A%84serializable/"/>
      <url>/2020/11/09/scala%E7%9A%84serializable/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是序列化">1 什么是序列化</h1><p><strong>把原本在内存中的对象状态 变成可存储或传输的过程称之为序列化。序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</strong></p><p>实现序列化的两个原因：</p><blockquote><ol><li>将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本；</li><li>按值将对象从一个应用程序域发送至另一个应用程序域。实现serializabel接口的作用是就是可以把对象存到字节流，然后可以恢复，所以你想如果你的对象没实现序列化怎么才能进行持久化和网络传输呢，要持久化和网络传输就得转为字节流，所以在分布式应用中及设计数据持久化的场景中，就得实现序列化。</li></ol></blockquote><h1 id="Scala-和-java-序列化">2 Scala 和 java 序列化</h1><p><strong>java <code>serializable</code></strong></p><blockquote><p>最好显示地指定 UID</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">private</span> String userId<span class="token punctuation">;</span>    <span class="token keyword">private</span> String userName<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>scala serializable</strong></p><blockquote><p>scala 序列化需要扩展Serializable 特质， 并加@Serializable 注解</p></blockquote><pre class=" language-scala"><code class="language-scala"><span class="token annotation punctuation">@SerialVersionUID</span><span class="token punctuation">(</span><span class="token number">100L</span><span class="token punctuation">)</span><span class="token keyword">class</span> Stock<span class="token punctuation">(</span><span class="token keyword">var</span> symbol<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token keyword">var</span> price<span class="token operator">:</span> BigDecimal<span class="token punctuation">)</span> <span class="token keyword">extends</span> Serializable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// code here ...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>_<span class="token comment" spellcheck="true">// create a serializable Stock class</span><span class="token annotation punctuation">@SerialVersionUID</span><span class="token punctuation">(</span><span class="token number">123L</span><span class="token punctuation">)</span><span class="token keyword">class</span> Stock<span class="token punctuation">(</span><span class="token keyword">var</span> symbol<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token keyword">var</span> price<span class="token operator">:</span> BigDecimal<span class="token punctuation">)</span> <span class="token keyword">extends</span> Serializable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">override</span> <span class="token keyword">def</span> toString <span class="token operator">=</span> f<span class="token string">"$symbol%s is $&amp;#123;price.toDouble&amp;#125;%.2f"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">object</span> SerializationDemo <span class="token keyword">extends</span> App <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (1) create a Stock instance</span>    <span class="token keyword">val</span> nflx <span class="token operator">=</span> <span class="token keyword">new</span> Stock<span class="token punctuation">(</span><span class="token string">"NFLX"</span><span class="token punctuation">,</span> BigDecimal<span class="token punctuation">(</span><span class="token number">85.00</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// (2) write the instance out to a file</span>    <span class="token keyword">val</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> ObjectOutputStream<span class="token punctuation">(</span><span class="token keyword">new</span> FileOutputStream<span class="token punctuation">(</span><span class="token string">"/tmp/nflx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    oos<span class="token punctuation">.</span>writeObject<span class="token punctuation">(</span>nflx<span class="token punctuation">)</span>    oos<span class="token punctuation">.</span>close    <span class="token comment" spellcheck="true">// (3) read the object back in</span>    <span class="token keyword">val</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> ObjectInputStream<span class="token punctuation">(</span><span class="token keyword">new</span> FileInputStream<span class="token punctuation">(</span><span class="token string">"/tmp/nflx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> stock <span class="token operator">=</span> ois<span class="token punctuation">.</span>readObject<span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span>Stock<span class="token punctuation">]</span>    ois<span class="token punctuation">.</span>close    <span class="token comment" spellcheck="true">// (4) print the object that was read back in</span>    println<span class="token punctuation">(</span>stock<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// NFLX is 85.00</span></code></pre><p>serializableUID的理解：</p><blockquote><p><code>serialVersionUID</code>是用来辅助对象的序列化与反序列化的，原则上序列化后的数据当中的<code>serialVersionUID</code>与当前类当中的<code>serialVersionUID</code>一致，那么该对象才能被反序列化成功。这个<code>serialVersionUID</code>的详细的工作机制是：在序列化的时候系统将<code>serialVersionUID</code>写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的<code>serialVersionUID</code>是否跟原对象的<code>serialVersionUID</code>是否一致，如果一直则反序列化成功，否则就说明当前类跟序列化后的类发生了变化。</p></blockquote><h1 id="序列化读写">3 序列化读写</h1><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//序列化过程</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">toSerial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectOutputStream objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"user.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        objectOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//反序列化过程</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fromSerial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ObjectInputStream objectInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"user.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> objectInputStream<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        objectInputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h1 id="自定义序列化">4 自定义序列化</h1><p>默认序列化会序列化所有的成员变量，或是当对象的实例变量引用了其他对象，那么序列化该对象的过程中也会把引用对象进行序列化，那么问题来了，1.我们不想序列化一些信息，比如关键的隐私信息，2. 当实例变量引用了大量的其他对象，那么序列化的成本也是很高的。 下面就简单说三种 自定义序列化方式。</p><h2 id="transient关键字">4.1 transient关键字</h2><blockquote><p>当某个字段被声明为 transient时，那么机制就会忽略它，对它不进行序列化</p></blockquote><h2 id="writeObject-方法与readObject-方法">4.2 writeObject()方法与readObject()方法</h2><p>解释下面代码</p><blockquote><p>我们将 age字段声明为了 transient，那么机制不会去序列化它，但是我们在类中多加了两个方法writeObject()方法与readObject()方法</p><p>我们在 <code>writeObject</code>中调用 ObjectOutputStream的ObjectOutputStream方法写进行序列化的写操作，因为 age 字段被声明了 trasient,此时会忽略它，而紧跟其后，我们又调用了 wirteInt方法，显示地将 age字段进行了序列化。在readObject中同理。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span>   <span class="token keyword">class</span>  <span class="token class-name">Person</span>  <span class="token keyword">implements</span>  <span class="token class-name">Serializable</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">private</span>  String name  <span class="token operator">=</span>   null <span class="token punctuation">;</span>     <span class="token keyword">private</span>  Integer age  <span class="token operator">=</span>   null <span class="token punctuation">;</span>     <span class="token keyword">private</span>  Gender gender  <span class="token operator">=</span>   null <span class="token punctuation">;</span>     <span class="token keyword">public</span>  <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">" none-arg constructor "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">public</span>  <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer age<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">" arg constructor "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span> <span class="token punctuation">.</span>name  <span class="token operator">=</span>  name<span class="token punctuation">;</span>         <span class="token keyword">this</span> <span class="token punctuation">.</span>age  <span class="token operator">=</span>  age<span class="token punctuation">;</span>         <span class="token keyword">this</span> <span class="token punctuation">.</span>gender  <span class="token operator">=</span>  gender<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// writeObject()方法与readObject()方法</span><span class="token keyword">public</span>   <span class="token keyword">class</span>  <span class="token class-name">Person</span>  <span class="token keyword">implements</span>  <span class="token class-name">Serializable</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">transient</span>   <span class="token keyword">private</span>  Integer age  <span class="token operator">=</span>   null <span class="token punctuation">;</span>     <span class="token keyword">private</span>   <span class="token keyword">void</span>  <span class="token function">writeObject</span><span class="token punctuation">(</span>ObjectOutputStream out<span class="token punctuation">)</span>  <span class="token keyword">throws</span>  IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">private</span>   <span class="token keyword">void</span>  <span class="token function">readObject</span><span class="token punctuation">(</span>ObjectInputStream in<span class="token punctuation">)</span>  <span class="token keyword">throws</span>  IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        in<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        age  <span class="token operator">=</span>  in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="Externalizable接口">4.3 Externalizable接口</h2><p><code>Externalizable</code>是继承自<code>Serializable</code>, 实现 <code>Externalizable</code>重写其两个方法，<code>writeExternal 、readExternal</code></p><p>下面这段代码中，对name与age字段进行序列化，忽略掉gender字段</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span>   <span class="token keyword">class</span>  <span class="token class-name">Person</span>  <span class="token keyword">implements</span>  <span class="token class-name">Externalizable</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">private</span>  String name  <span class="token operator">=</span>   null <span class="token punctuation">;</span>     <span class="token keyword">transient</span>   <span class="token keyword">private</span>  Integer age  <span class="token operator">=</span>   null <span class="token punctuation">;</span>     <span class="token keyword">private</span>  Gender gender  <span class="token operator">=</span>   null <span class="token punctuation">;</span>     <span class="token keyword">public</span>  <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">" none-arg constructor "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">public</span>  <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer age<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">" arg constructor "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span> <span class="token punctuation">.</span>name  <span class="token operator">=</span>  name<span class="token punctuation">;</span>         <span class="token keyword">this</span> <span class="token punctuation">.</span>age  <span class="token operator">=</span>  age<span class="token punctuation">;</span>         <span class="token keyword">this</span> <span class="token punctuation">.</span>gender  <span class="token operator">=</span>  gender<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span>   <span class="token keyword">void</span>  <span class="token function">writeExternal</span><span class="token punctuation">(</span>ObjectOutput out<span class="token punctuation">)</span>  <span class="token keyword">throws</span>  IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span>   <span class="token keyword">void</span>  <span class="token function">readExternal</span><span class="token punctuation">(</span>ObjectInput in<span class="token punctuation">)</span>  <span class="token keyword">throws</span>  IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        name  <span class="token operator">=</span>  <span class="token punctuation">(</span>String<span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        age  <span class="token operator">=</span>  in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*arg constructornone - arg constructor[John,  31 ,  null ]*/</span></code></pre><p><strong>若使用Externalizable进行序列化，当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。这就是为什么在此次序列化过程中Person类的无参构造器会被调用。由于这个原因，实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。</strong></p><h1 id="readSolve（）方法">5 readSolve（）方法</h1><p> 当我们使用Singleton模式时，应该是期望某个类的实例应该是唯一的，但如果该类是可序列化的，那么情况可能会略有不同。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">private</span>  <span class="token keyword">static</span>  <span class="token keyword">class</span> <span class="token class-name">InstanceHolder</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">private</span>  <span class="token keyword">static</span>  <span class="token keyword">final</span> Person instatnce <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span> <span class="token string">" John "</span> <span class="token punctuation">,</span> <span class="token number">31</span> <span class="token punctuation">,</span> Gender<span class="token punctuation">.</span>MALE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">public</span>  <span class="token keyword">static</span> Person <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> InstanceHolder<span class="token punctuation">.</span>instatnce<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> String name <span class="token operator">=</span>  null <span class="token punctuation">;</span>   <span class="token keyword">private</span> Integer age <span class="token operator">=</span>  null <span class="token punctuation">;</span>   <span class="token keyword">private</span> Gender gender <span class="token operator">=</span>  null <span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">" none-arg constructor "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer age<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">" arg constructor "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">this</span> <span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>     <span class="token keyword">this</span> <span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>     <span class="token keyword">this</span> <span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">SimpleSerial</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">public</span>  <span class="token keyword">static</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    File file <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span> <span class="token string">" person.out "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    ObjectOutputStream oout <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    oout<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存单例对象</span>    oout<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       ObjectInputStream oin <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       Object newPerson <span class="token operator">=</span> oin<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  oin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>newPerson<span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> newPerson<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将获取的对象与Person类中的单例对象进行相等性比较</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*arg constructor[John,  31 , MALE]false*/</span></code></pre><hr><p><strong>从文件person.out中获取的Person对象与Person类中的单例对象并不相等。为了能在序列化过程仍能保持单例的特性，可以在Person类中添加一个readResolve()方法</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">private</span>  <span class="token keyword">static</span>  <span class="token keyword">class</span> <span class="token class-name">InstanceHolder</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">private</span>  <span class="token keyword">static</span>  <span class="token keyword">final</span> Person instatnce <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span> <span class="token string">" John "</span> <span class="token punctuation">,</span> <span class="token number">31</span> <span class="token punctuation">,</span> Gender<span class="token punctuation">.</span>MALE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">public</span>  <span class="token keyword">static</span> Person <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> InstanceHolder<span class="token punctuation">.</span>instatnce<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> String name <span class="token operator">=</span>  null <span class="token punctuation">;</span>   <span class="token keyword">private</span> Integer age <span class="token operator">=</span>  null <span class="token punctuation">;</span>   <span class="token keyword">private</span> Gender gender <span class="token operator">=</span>  null <span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">" none-arg constructor "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer age<span class="token punctuation">,</span> Gender gender<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">" arg constructor "</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">this</span> <span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>     <span class="token keyword">this</span> <span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>     <span class="token keyword">this</span> <span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> Object <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ObjectStreamException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> InstanceHolder<span class="token punctuation">.</span>instatnce<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*arg constructor[John,  31 , MALE]true*/</span></code></pre><p><strong>无论是实现Serializable接口，或是Externalizable接口，当从I/O流中读取对象时，readResolve()方法都会被调用。反序列化的过程实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象，而被创建的对象则会被垃圾回收掉。</strong></p><h1 id="总结">6 总结</h1><ol><li>序列化作用的对象是类的实例.对实例进行序列化,就是保存实例当前在内存中的状态.包括实例的每一个属性的值和引用等.</li><li>想要实现序列化必须实现Serializable接口，</li><li>序列化时，只对对象的状态进行保存，而不管对象的方法；</li><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li><li>默认序列化机制中当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； </li><li>序列化会忽略静态变量，即序列化不保存静态变量的状态。静态成员属于类级别的，不能序列化。添加了static、transient关键字后的变量不能序列化。</li></ol><h1 id="参考">7 参考</h1><ol><li><a href="https://alvinalexander.com/scala/how-to-use-serialization-in-scala-serializable-trait/">Scala Serializable的使用</a></li><li><a href="https://blog.csdn.net/dreamtdp/article/details/15378329?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">对Java Serializable（序列化）的理解和总结</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scala断言和参数检查</title>
      <link href="/2020/11/07/scala%E6%96%AD%E8%A8%80%E5%92%8C%E5%8F%82%E6%95%B0%E6%A3%80%E6%9F%A5/"/>
      <url>/2020/11/07/scala%E6%96%AD%E8%A8%80%E5%92%8C%E5%8F%82%E6%95%B0%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>scala 的参数检查与断言: require, assert, assume 和 ensuring</p><p>总结：</p><blockquote><p><strong>require() 方法用在对参数的检验上，不通过则抛出 IllegalArgumentException</strong></p><p><strong><code>assert()</code> 或 <code>assume()</code> 方法在对中间结果或私有方法的参数进行检验，不成功则抛出 <code>AssertionError</code> 异常</strong></p></blockquote><blockquote><p><strong><code>ensuring() </code>方法在返回结果的分支的花括号同一行上进行断言. ensuring 是用来对返回结果行断言的，所以它必须尾随返回结果处,nsuring 中用 “_” 作为当前返回结果对象的占位符</strong></p><p><strong><code>ensuring</code>应该放在返回结果分支的花括号后面，如果没有花括号，应该造花括号让它跟，或是写在函数后最后那个花括号的后面</strong></p><p><strong>要使用<code>ensuring()</code>, 则必须有<code>{}</code></strong></p><hr></blockquote><pre class=" language-scala"><code class="language-scala"><span class="token keyword">private</span> <span class="token keyword">def</span> widen<span class="token punctuation">(</span>w<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> Element <span class="token operator">=</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>w <span class="token operator">&lt;=</span> width<span class="token punctuation">)</span>        <span class="token keyword">this</span>    <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">val</span> left <span class="token operator">=</span> elem<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>w <span class="token operator">-</span> width<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> height<span class="token punctuation">)</span>        <span class="token keyword">var</span> right <span class="token operator">=</span> elem<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>w <span class="token operator">-</span> width <span class="token operator">-</span>left<span class="token punctuation">.</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>        left beside <span class="token keyword">this</span> beside right    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> ensuring <span class="token punctuation">(</span>w <span class="token operator">&lt;=</span> _<span class="token punctuation">.</span>width<span class="token punctuation">)</span> </code></pre><pre class=" language-scala"><code class="language-scala"><span class="token keyword">private</span> <span class="token keyword">def</span> widen<span class="token punctuation">(</span>w<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> Element <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>w <span class="token operator">&lt;</span> width<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> ensuring<span class="token punctuation">(</span>_<span class="token punctuation">.</span>width <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这里欲断言返回结果 this，所有两 if 后的花括号不能省略</span>    <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">val</span> left <span class="token operator">=</span> elem<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>w <span class="token operator">-</span> width<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> height<span class="token punctuation">)</span>        <span class="token keyword">var</span> right <span class="token operator">=</span> elem<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>w <span class="token operator">-</span> width <span class="token operator">-</span> left<span class="token punctuation">.</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>        left beside <span class="token keyword">this</span> beside right    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> ensuring<span class="token punctuation">(</span>w <span class="token operator">&lt;=</span> _<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//断言的是上一行 left beside this beside right 结果</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> ensuring<span class="token punctuation">(</span><span class="token punctuation">(</span>w <span class="token operator">+</span> _<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//ensuring 断言可以放在方法体外了，用来断言最终的结果</span></code></pre><p>参考：</p><p><a href="https://yanbin.blog/scala-parameter-check-and-assertion/">参考</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scala的reflect</title>
      <link href="/2020/11/07/scala%E7%9A%84reflect/"/>
      <url>/2020/11/07/scala%E7%9A%84reflect/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要reflect">1 为什么需要reflect</h1><p>Scala是基于JVM的语言, Scala编译器会将Scala代码编译成JVM字节码, 而JVM编译过程中JVM中的泛型并不会保存。下面这段代码并不会通过</p><pre class=" language-scala"><code class="language-scala"><span class="token keyword">class</span> ScalaDemo<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">def</span> makeTArray<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Array<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> Array<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>那么问题来了，假如我们有一种对象可以保存泛型信息，不就解决了吗，那么解决办法来了，这些对象就是<code>ClassTag 、Manifest、ClassManifest、TypeTag</code></p><p><strong>反射作用三部曲</strong>：</p><blockquote><p>捕获对象、泛型类型信息</p><p>根据捕获信息实例化新对象</p><p>通过实例操作对象的属性和方法</p></blockquote><p>反射的种类：</p><p>1、scala.reflect.runtime.universe 运行时的反射</p><p>2、scala.reflect.marcos.universe编译期的反射</p><h1 id="运行期时反射">2 运行期时反射</h1><p>我们重点讲解运行期反射:</p><p>Scala运行时类型信息是保存在TypeTag对象中, 编译器在编译过程中将类型信息保存到TypeTag中, 并将其携带到运行期. 通过TypeTag的 <code>typeTag</code>方法获得需要的Type(如果不是从对象换取Type 而是从class中获得 可以直接用 typeOf[类名])</p><pre class=" language-scala"><code class="language-scala">scala<span class="token operator">></span> <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">val</span> list<span class="token operator">:</span> List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>scala<span class="token operator">></span> <span class="token keyword">def</span> getType<span class="token punctuation">[</span>T<span class="token operator">:</span>TypeTag<span class="token punctuation">]</span><span class="token punctuation">(</span>obj<span class="token operator">:</span>T<span class="token punctuation">)</span> <span class="token operator">=</span> typeTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token keyword">def</span> getType<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span> evidence$<span class="token number">1</span><span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>TypeTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>TypeTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span>scala<span class="token operator">></span> getType<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">val</span> res1<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>TypeTag<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> TypeTag<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>scala<span class="token operator">></span> <span class="token keyword">def</span> getType1<span class="token punctuation">[</span>T<span class="token operator">:</span> TypeTag<span class="token punctuation">]</span><span class="token punctuation">(</span>obj<span class="token operator">:</span>T<span class="token punctuation">)</span> <span class="token operator">=</span> typeOf<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token keyword">def</span> getType1<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span> evidence$<span class="token number">1</span><span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>TypeTag<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>Typescala<span class="token operator">></span> getType1<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">val</span> res2<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>Type <span class="token operator">=</span> List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span></code></pre><p>想要获得擦除后的类型信息, 可以使用<code>ClassTag</code></p><pre class=" language-scala"><code class="language-scala">scala<span class="token operator">></span> <span class="token keyword">import</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>_<span class="token keyword">import</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>_scala<span class="token operator">></span> <span class="token keyword">import</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>_<span class="token keyword">import</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>_scala<span class="token operator">></span> <span class="token keyword">val</span> tpeTag <span class="token operator">=</span> typeTag<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span>tpeTag<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>TypeTag<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> TypeTag<span class="token punctuation">[</span>scala<span class="token punctuation">.</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span>scala<span class="token operator">></span> <span class="token keyword">val</span> clsTag <span class="token operator">=</span> classTag<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span>clsTag<span class="token operator">:</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>ClassTag<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>immutable<span class="token punctuation">.</span>Listscala<span class="token operator">></span> clsTag<span class="token punctuation">.</span>runtimeClassres12<span class="token operator">:</span> Class<span class="token punctuation">[</span>_<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">class</span> scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>immutable<span class="token punctuation">.</span>Listscala<span class="token operator">></span> classOf<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span>res0<span class="token operator">:</span> Class<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">class</span> scala<span class="token punctuation">.</span>collection<span class="token punctuation">.</span>immutable<span class="token punctuation">.</span>List</code></pre><h1 id="反射的实际应用">3 反射的实际应用</h1><h2 id="运行时类型实例化">3.1 运行时类型实例化</h2><pre class=" language-scala"><code class="language-scala">scala<span class="token operator">></span> <span class="token keyword">case</span> <span class="token keyword">class</span> Fruits<span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>defined <span class="token keyword">class</span> Fruitsscala<span class="token operator">></span> <span class="token keyword">import</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>_<span class="token keyword">import</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>_<span class="token comment" spellcheck="true">// 获得当前JVM中的所有类镜像</span>scala<span class="token operator">></span> <span class="token keyword">val</span> rm <span class="token operator">=</span> runtimeMirror<span class="token punctuation">(</span>getClass<span class="token punctuation">.</span>getClassLoader<span class="token punctuation">)</span>rm<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>Mirror <span class="token operator">=</span> JavaMirror <span class="token keyword">with</span> scala<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>nsc<span class="token punctuation">.</span>interpreter<span class="token punctuation">.</span>IMain$TranslatingClassLoader<span class="token annotation punctuation">@566edb2e</span> of <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 获得`Fruits`的类型符号, 并指定为class类型</span>scala<span class="token operator">></span> <span class="token keyword">val</span> classFruits <span class="token operator">=</span> typeOf<span class="token punctuation">[</span>Fruits<span class="token punctuation">]</span><span class="token punctuation">.</span>typeSymbol<span class="token punctuation">.</span>asClassclassFruits<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>ClassSymbol <span class="token operator">=</span> <span class="token keyword">class</span> Fruits<span class="token comment" spellcheck="true">// 根据上一步的符号, 从所有的类镜像中, 取出`Fruits`的类镜像</span><span class="token keyword">val</span> cm <span class="token operator">=</span> rm<span class="token punctuation">.</span>reflectClass<span class="token punctuation">(</span>classFruits<span class="token punctuation">)</span>cm<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>ClassMirror <span class="token operator">=</span> <span class="token keyword">class</span> mirror <span class="token keyword">for</span> Fruits <span class="token punctuation">(</span>bound to <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 获得`Fruits`的构造函数, 并指定为asMethod类型</span>scala<span class="token operator">></span> <span class="token keyword">val</span> ctor <span class="token operator">=</span> typeOf<span class="token punctuation">[</span>Fruits<span class="token punctuation">]</span><span class="token punctuation">.</span>declaration<span class="token punctuation">(</span>nme<span class="token punctuation">.</span>CONSTRUCTOR<span class="token punctuation">)</span><span class="token punctuation">.</span>asMethodctor<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>MethodSymbol <span class="token operator">=</span> constructor Fruits<span class="token comment" spellcheck="true">// 根据上一步的符号, 从`Fruits`的类镜像中, 取出一个方法(也就是构造函数)</span>scala<span class="token operator">></span> <span class="token keyword">val</span> ctorm <span class="token operator">=</span> cm<span class="token punctuation">.</span>reflectConstructor<span class="token punctuation">(</span>ctor<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 调用构造函数, 反射生成类实例, 完成</span>scala<span class="token operator">></span> ctorm<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"apple"</span><span class="token punctuation">)</span>res2<span class="token operator">:</span> <span class="token builtin">Any</span> <span class="token operator">=</span> Fruits<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>apple<span class="token punctuation">)</span></code></pre><h2 id="运行时类成员操作">3.2 运行时类成员操作</h2><pre class=" language-scala"><code class="language-scala">scala<span class="token operator">></span> <span class="token keyword">case</span> <span class="token keyword">class</span> Fruits<span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>defined <span class="token keyword">class</span> Fruitsscala<span class="token operator">></span> <span class="token keyword">import</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>_<span class="token keyword">import</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>_<span class="token comment" spellcheck="true">// 获得当前JVM中的所有类镜像</span>scala<span class="token operator">></span> <span class="token keyword">val</span> rm <span class="token operator">=</span> runtimeMirror<span class="token punctuation">(</span>getClass<span class="token punctuation">.</span>getClassLoader<span class="token punctuation">)</span>rm<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>Mirror <span class="token operator">=</span> JavaMirror <span class="token keyword">with</span> scala<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>nsc<span class="token punctuation">.</span>interpreter<span class="token punctuation">.</span>IMain$TranslatingClassLoader<span class="token annotation punctuation">@566edb2e</span> of <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 生成一个`Fruits`的实例</span>scala<span class="token operator">></span> <span class="token keyword">val</span> fruits <span class="token operator">=</span> Fruits<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">)</span>fruits<span class="token operator">:</span> Fruits <span class="token operator">=</span> Fruits<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>banana<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 根据`Fruits`的实例生成实例镜像</span><span class="token keyword">val</span> instm <span class="token operator">=</span> rm<span class="token punctuation">.</span>reflect<span class="token punctuation">(</span>fruits<span class="token punctuation">)</span>instm<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>InstanceMirror <span class="token operator">=</span> instance mirror <span class="token keyword">for</span> Fruits<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>banana<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 获得`Fruits`中, 名字为name的成员信息, 并指定为asTerm类型符号</span>scala<span class="token operator">></span> <span class="token keyword">val</span> nameTermSymbol <span class="token operator">=</span> typeOf<span class="token punctuation">[</span>Fruits<span class="token punctuation">]</span><span class="token punctuation">.</span>declaration<span class="token punctuation">(</span>newTermName<span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asTermnameTermSymbol<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>TermSymbol <span class="token operator">=</span> value name<span class="token comment" spellcheck="true">// 根据上一步的符号, 从`Fruits`的实例镜像中, 取出一个成员的指针</span>scala<span class="token operator">></span> <span class="token keyword">val</span> nameFieldMirror <span class="token operator">=</span> instm<span class="token punctuation">.</span>reflectField<span class="token punctuation">(</span>nameTermSymbol<span class="token punctuation">)</span>nameFieldMirror<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>FieldMirror <span class="token operator">=</span> field mirror <span class="token keyword">for</span> <span class="token keyword">private</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token keyword">val</span> name<span class="token operator">:</span> <span class="token builtin">String</span> <span class="token punctuation">(</span>bound to Fruits<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>banana<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 通过get方法访问成员信息</span>scala<span class="token operator">></span> nameFieldMirror<span class="token punctuation">.</span>getres3<span class="token operator">:</span> <span class="token builtin">Any</span> <span class="token operator">=</span> banana<span class="token comment" spellcheck="true">// 通过set方法, 改变成员信息</span>scala<span class="token operator">></span> nameFieldMirror<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 再次查询, 发现成员的值已经改变, 即便是val, 在反射中也可以改变</span>scala<span class="token operator">></span> nameFieldMirror<span class="token punctuation">.</span>getres6<span class="token operator">:</span> <span class="token builtin">Any</span> <span class="token operator">=</span> apple</code></pre><h2 id="运行时方法操作">3.3 运行时方法操作</h2><pre class=" language-scala"><code class="language-scala">  <span class="token keyword">def</span> getMethod<span class="token punctuation">(</span>className<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> methodName<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token operator">:</span> universe<span class="token punctuation">.</span>MethodMirror <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取实例</span>    <span class="token keyword">val</span> classInstance <span class="token operator">=</span> Class<span class="token punctuation">.</span>forName<span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">.</span>newInstance<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 实例镜像</span>    <span class="token keyword">val</span> instanceMirror <span class="token operator">=</span> runtimeMirror<span class="token punctuation">.</span>reflect<span class="token punctuation">(</span>classInstance<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 全局可访问类符号</span>    <span class="token keyword">val</span> classSymbol <span class="token operator">=</span> runtimeMirror<span class="token punctuation">.</span>staticClass<span class="token punctuation">(</span>className<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 方法符号</span>    <span class="token keyword">val</span> methodSymbol <span class="token operator">=</span> classSymbol<span class="token punctuation">.</span>selfType<span class="token punctuation">.</span>decl<span class="token punctuation">(</span>scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>TermName<span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asMethod    <span class="token comment" spellcheck="true">// 反射</span>    instanceMirror<span class="token punctuation">.</span>reflectMethod<span class="token punctuation">(</span>methodSymbol<span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h1 id="ClassTag-、Manifest、ClassManifest、TypeTag">4 ClassTag 、Manifest、ClassManifest、TypeTag</h1><p>scala在2.10用TypeTag替代了Manifest，用ClassTag替代了ClassManifest.原因是在路径依赖类型中，Manifest存在问题</p><p>下面这个实例中 <code>mfun(f1)(b1) == mfun(f2)(b2)</code> 理应是 <code>false</code>,因为b1和b2依赖的外部实例是不一样的。</p><pre class=" language-scala"><code class="language-scala">scala<span class="token operator">></span> <span class="token keyword">class</span> Foo<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">class</span> Bar<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>defined <span class="token keyword">class</span> Fooscala<span class="token operator">></span> <span class="token keyword">val</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">;</span><span class="token keyword">val</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> f1<span class="token punctuation">.</span>Barf1<span class="token operator">:</span> Foo <span class="token operator">=</span> Foo<span class="token annotation punctuation">@994f7fd</span>b1<span class="token operator">:</span> f1<span class="token punctuation">.</span>Bar <span class="token operator">=</span> Foo$Bar<span class="token annotation punctuation">@1fc0e258</span>scala<span class="token operator">></span> <span class="token keyword">val</span> f2 <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">;</span><span class="token keyword">val</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> f2<span class="token punctuation">.</span>Barf2<span class="token operator">:</span> Foo <span class="token operator">=</span> Foo<span class="token annotation punctuation">@ecd59a3</span>b2<span class="token operator">:</span> f2<span class="token punctuation">.</span>Bar <span class="token operator">=</span> Foo$Bar<span class="token annotation punctuation">@15c882e8</span>scala<span class="token operator">></span> <span class="token keyword">def</span> mfun<span class="token punctuation">(</span>f<span class="token operator">:</span> Foo<span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">:</span> f<span class="token punctuation">.</span>Bar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span> ev<span class="token operator">:</span> Manifest<span class="token punctuation">[</span>f<span class="token punctuation">.</span>Bar<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> evmfun<span class="token operator">:</span> <span class="token punctuation">(</span>f<span class="token operator">:</span> Foo<span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">:</span> f<span class="token punctuation">.</span>Bar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span> ev<span class="token operator">:</span> scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Manifest<span class="token punctuation">[</span>f<span class="token punctuation">.</span>Bar<span class="token punctuation">]</span><span class="token punctuation">)</span>scala<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Manifest<span class="token punctuation">[</span>f<span class="token punctuation">.</span>Bar<span class="token punctuation">]</span>scala<span class="token operator">></span> <span class="token keyword">def</span> tfun<span class="token punctuation">(</span>f<span class="token operator">:</span> Foo<span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">:</span> f<span class="token punctuation">.</span>Bar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span> ev<span class="token operator">:</span> TypeTag<span class="token punctuation">[</span>f<span class="token punctuation">.</span>Bar<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> evtfun<span class="token operator">:</span> <span class="token punctuation">(</span>f<span class="token operator">:</span> Foo<span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">:</span> f<span class="token punctuation">.</span>Bar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span> ev<span class="token operator">:</span> reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>TypeTag<span class="token punctuation">[</span>f<span class="token punctuation">.</span>Bar<span class="token punctuation">]</span><span class="token punctuation">)</span>reflect<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>universe<span class="token punctuation">.</span>TypeTag<span class="token punctuation">[</span>f<span class="token punctuation">.</span>Bar<span class="token punctuation">]</span>scala<span class="token operator">></span> mfun<span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">==</span> mfun<span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span>res14<span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span>scala<span class="token operator">></span> tfun<span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span> <span class="token operator">==</span> tfun<span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span>res15<span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><blockquote><p><code>ClassManifest</code>是<code>Manifest</code>的一个弱化版本，保存的类型信息不如<code>Manifest</code>多, 而<code>ClassTag</code>是<code>TypeTag</code>的一个弱化版本.在实际应用中，SparkContext大量使用<code>ClassTag</code>保存泛型信息，一般情况下<code>ClassTag</code>就满足我们使用。</p></blockquote><h1 id="总结">5 总结</h1><blockquote><ol><li><p><code>ClassTag</code> 可以获取擦除后的类型信息，再<code>scala.reflect</code>中，有<code>classTag</code>和<code>classof</code>两个主要方法</p></li><li><p><code>TypeTag</code>获取运行时的类型信息，在<code>scala.reflect.runtime.universe</code>中，有<code>typeTag</code>和<code>typeOf</code>两个主要方法。</p></li><li><p><code>runtimeMirror(getClass.getClassLoader)</code> 反射类<code>reflectClass()</code>, 反射实例<code>reflect()</code>,反射成员变量<code>reflectField()</code>,反射静态类<code>staticClass</code>…</p></li><li><p>不论我们是去操作方法还是实例化对象或是操作属性，流程大致都一致，获取类镜像是必经之路，然后去做反射，最后操作。</p></li><li><p><code>scala.reflect.runtime.universeruntimeMirror(getClass.getClassLoader)</code>获取当前jvm中所有的的运行类镜像。</p></li></ol></blockquote><h1 id="参考">6 参考</h1><ol><li><a href="https://developer.aliyun.com/article/641350">一篇入门 – Scala 反射</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetCode_1106_1356</title>
      <link href="/2020/11/06/daily-leetCode-2020-1106-1356/"/>
      <url>/2020/11/06/daily-leetCode-2020-1106-1356/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">1 题目描述</h1><blockquote><p>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。</p><p>如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。</p><p>请你返回排序后的数组。</p></blockquote><pre><code>输入：arr = [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]解释：[0] 是唯一一个有 0 个 1 的数。[1,2,4,8] 都有 1 个 1 。[3,5,6] 有 2 个 1 。[7] 有 3 个 1 。按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。输入：arr = [10000,10000]输出：[10000,10000]输入：arr = [2,3,5,7,11,13,17,19]输出：[2,3,5,17,7,11,13,19]输入：arr = [10,100,1000,10000]输出：[10,100,10000,1000]1 &lt;= arr.length &lt;= 5000 &lt;= arr[i] &lt;= 10^4</code></pre><h1 id="分析问题">2 分析问题</h1><blockquote><p>问题的本质就是一个排序问题，而不同平常的排序，多了一项条件，就是根据 其二进制表示中1的数目来排序，而数目相同则按数字的大小排序，如果你学过java，到这里 我想你应该知道 如何操作了。Array.sort(arr)</p></blockquote><hr><p>非常清晰的问题：</p><ol><li>统计序列中每个数的二进制表示中1的个数</li><li>利用上一步得到的结果数本身进行排序操作</li></ol><p>两个步骤中，均有常规版操作以及优化</p><h1 id="步步解题">3 步步解题</h1><ol><li>第一步，统计序列中每个数的二进制表示中1的个数</li></ol><p><strong>方法1，求得二进制序列，然后做统计</strong></p><p><strong><em>十进制转二进制</em></strong></p><ol><li>最常规的，<strong>求模取逆</strong></li></ol><pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">""" 求一个数的进制 """</span><span class="token keyword">def</span> <span class="token function">get_num_bin</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">:</span>    res_str <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">while</span> number<span class="token punctuation">:</span>        tmp <span class="token operator">=</span> number <span class="token operator">%</span> <span class="token number">2</span>        res_str <span class="token operator">=</span> str<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token operator">+</span> res_str        number <span class="token operator">//=</span> <span class="token number">2</span>    <span class="token keyword">return</span> res_str </code></pre><ol start="2"><li>递归求二进制</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_num_bin</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> number <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> number    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> get_num_bin<span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>n<span class="token operator">%</span><span class="token number">2</span></code></pre><ol start="3"><li>和方法一类似，可以用数组存放、或者累乘法表示成正数，如果有负数要注意变号处理</li></ol><p>求得二进制后，我们便可以统计 1的个数。</p><hr><p><strong>方法2，巧妙的位运算</strong></p><p>另一种方法，不用显示地去求二进制的表示，便可以求其中1的个数，那就这就涉及到了<em>位运算</em></p><p>给定一个数的二进制，我们开始从最右边开始起判断，计数1的个数=&gt; 那么问题来了，如何判断最右边的数是1呢？第二个问题，何时结束呢？</p><p>如果能想到0，1这两个特殊的数字以及位运算操作，那么解决办法就来了。</p><blockquote><ol><li>1的二进制表示还是1，当用1与一个数做与运算时，得到的结果如果是1，那么最右边就是1，得到结果为0，那么就不是1。</li><li>何时结束，当然是遍历到最左边了，但是我们没必要知道二进制序列多长，况且我们还是从后面往前面走，如果去循环遍历判断计算1的个数，那和前面的方法没有什么区别了。另一种<code>while</code>式的思考方法当然是序列中没有1了，那我们就没有必要继续判断了。那么问题来了，如何判断序列中没有1了呢？ 那么解决办法来了=&gt; 0的二进制还是0，是唯一一个二进制表示没有1的数。假如我们有一种方法，使得这个数不断地向0靠近，并且保证最右边一位被更新。那么这种方法就是 <strong>右移</strong></li></ol></blockquote><p>根据前面的分析，写处代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_a_number_bin_count</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    得到一个数的二进制表示形式中 1 的个数    :param number:    :return:    """</span>    res_count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> number<span class="token punctuation">:</span>        <span class="token keyword">if</span> number <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">:</span>            res_count <span class="token operator">+=</span> <span class="token number">1</span>         number <span class="token operator">=</span> number <span class="token operator">>></span><span class="token number">1</span>     <span class="token keyword">return</span> res_count</code></pre><p>但是上面的代码对于负数就不那么通用了，虽然此题的所有测试样例都是正数，但是有必要学习更加适用的方法。</p><hr><p>我们先来观察一个整数与它的次小整数 在二进制表示上的区别，二进制的含义是什么=&gt; 满二进1。一个数加1，会发生的情况：最右边加1，满2进1，该位变0。进为后下一位为2那么继续进位，该位变0，如果进位后位1，那么就停止。我们可以发现的是，一个数加1后，在位表示上的变化是 <strong>遇到一个白马王子-&gt;1停止，而这个白马王子是最次等的，是这个数加1后最右边的那个1，或许再往左还有更好的，但是它满足了，停止脚步了</strong>.</p><p>从上面的分析中，我们可以得出一个结论：<strong>一个整数与它的次小整数在二进制表示上的差异是: 将该数右边的1变为0，最右边那个1的右边的所有位变为1</strong>。以1100得到1011为例</p><p>有了上面的结论，我们去做个小实验： <strong>用一个整数和它的次小整数做 与 运算，发现操作结果恰恰是将这个整数最右边的1变为了0</strong></p><p>1100 &amp; 1011 = 1000</p><p>根据前面的分析，我们可以写处这样的代码</p><pre class=" language-python"><code class="language-python">        <span class="token keyword">def</span> <span class="token function">get_a_number_bin_count</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">"""            得到一个数的二进制表示形式中 1 的个数            :param number:            :return:            """</span>            res_count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">while</span> number<span class="token punctuation">:</span>                number <span class="token operator">=</span> number <span class="token operator">&amp;</span> <span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                res_count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> res_count</code></pre><ol start="2"><li>利用上一步得到的结果与数本身进行排序操作, </li></ol><p>最简单的冒泡排序</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">sort_by_bits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        根据数字的二进制形式中的1的个数 对 array 进行排序        :param array:        :return: a array,排好序的结果        """</span>        <span class="token keyword">def</span> <span class="token function">get_a_number_bin_count</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">"""            得到一个数的二进制表示形式中 1 的个数            :param number:            :return:            """</span>            res_count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">while</span> number<span class="token punctuation">:</span>                number <span class="token operator">=</span> number <span class="token operator">&amp;</span> <span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                res_count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> res_count        tmp_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> get_a_number_bin_count<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> array<span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>tmp_list<span class="token punctuation">)</span>        <span class="token triple-quoted-string string">""" 排序 """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>tmp_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>tmp_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> tmp_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> tmp_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    tmp_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>tmp_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>tmp_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> tmp_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> tmp_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        tmp_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>tmp_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>tmp_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> tmp_list<span class="token punctuation">]</span></code></pre><p>利用现成的:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">return</span> sorted<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>get_a_number_bin_count<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></code></pre><p>当然，如果你对<code>python</code>的常用函数熟悉，你还可以写处更简短的代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">return</span> sorted<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>bin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></code></pre><h1 id="总结">4 总结</h1><ol><li>一个整数的二进制上最右边的1变为0，最右边那个1的右边的所有位变为1，便得到次小整数</li><li>0是唯一一个二进制表示没有1的数</li><li>一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetCode_2020_1104_57_插入区间</title>
      <link href="/2020/11/04/daily-leetCode-2020-1104-57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
      <url>/2020/11/04/daily-leetCode-2020-1104-57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong></p><blockquote><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。<br>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>输出：[[1,2],[3,10],[12,16]]<br>解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10]重叠。</p><p>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>输出：[[1,2],[3,10],[12,16]]<br>解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</p></blockquote><p><strong><em>题解</em></strong></p><p>审题：</p><blockquote><ol><li>source序列是有序的，每个 元也是有序的，而且是无重叠的</li><li>一个新元是有序的</li></ol></blockquote><p>目标： 将新元插入到source，保证有序且不重叠</p><p>关键点：</p><ol><li>处理 有重叠的 </li><li>继续保证有序</li></ol><p>思路：</p><ol><li>线性扫描source， 遇到不重叠的且 该排在 新元 前面的，存放到 res</li><li>遇到重叠的进行和并：下界取两者最小的，上界取两者最大的，更新到 新元中，</li><li>将新元保存到res中，将source中剩下的没有遍历的(肯定是排在更新的新元后面的)放到res</li></ol><p>例子详解：</p><p>[[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]]， [4, 8]</p><blockquote><p>遍历source，index=0为[1,2]， [1,2]整体是在[4,8] 左边的(比它小), 将[1,2]加入的res中，res=[[1,2],]</p></blockquote><blockquote><p>index=1为[3,5], [3,5]与[4,8]是有交叉的，根据上面思路中2更新 新元， 新元为[min (3,4) , max (5,8) ] = [3,8]</p><p>index=2w为[6,7]，与[3,8]有交叉，更新后的新元为 [3,8]</p><p>index=3为[8,10], 与[3,8]有交叉，更新后的新元为 [3,10]</p></blockquote><blockquote><p>index=4 时为[12,16], 与[3,10]没有交叉，且需要保存在[3,10]后面，此时将[3,10]加入到res中，res=[[1,2],[3,10]]</p></blockquote><blockquote><p>从[12,16]开始到遍历完，将所有的加入到res中， 最终结果为： res=[[1,2],[3,10],[12,16]]</p></blockquote><p>根据上面的思路写出代码：</p><pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">"""author: jdi146contact: jdi147.com@gmail.comdatetime: 2020/11/4 13:50"""</span><span class="token triple-quoted-string string">"""特例：1. [[]],[1,2]2. [[]], [],"""</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">,</span> newInterval<span class="token punctuation">)</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        index <span class="token operator">=</span> <span class="token number">0</span>        source_len <span class="token operator">=</span> len<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span>        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> source_len <span class="token operator">and</span> intervals<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>            index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> source_len <span class="token operator">and</span> intervals<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> newInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> intervals<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            newInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> newInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            index <span class="token operator">+=</span> <span class="token number">1</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>newInterval<span class="token punctuation">)</span>        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> source_len<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>            index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        intervals <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        newInterval <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> newInterval<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    sol <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    sol<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>原题链接[<a href="https://leetcode-cn.com/problems/insert-interval/">57. 插入区间</a>]</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>daily_leetCode_2020_1103_941_有效的山脉数组</title>
      <link href="/2020/11/04/daily-leetCode-2020-1103-941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
      <url>/2020/11/04/daily-leetCode-2020-1103-941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong></p><blockquote><p>给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。</p><p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p><p>A.length &gt;= 3<br>在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：<br>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]<br>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</p></blockquote><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/daily_leetCode/image-20201104232027110.png" alt="image-20201104232027110"></p><p><strong><em>题解</em></strong></p><p>数组的特点：</p><ol><li>没有重复元，可以看作两个拥有一个共同最大值、sort方向相反的序列对接（先这样理解)。那么问题来了，关键点在与寻找峰值。</li></ol><p>假设这就是一个有效的山脉数组，那么</p><blockquote><ol><li>从头开始寻找峰值，在这个过程中<strong>判断第一个序列是否是无重复递增, 将峰值保存</strong></li><li>接着上一步，从峰值开始后面的是一个递减的序列（如果是有效山脉），<strong>遍历第二个序列判断它是否是无重复递减的</strong></li><li>当两个都遍历完没有问题时，就True掉，有问题时就在遍历的过程中False 掉。</li></ol></blockquote><p>到这里为止，大部分测试用例都可以跑通，但是上面的分析判断是基于两个序列</p><blockquote><ol><li>给测试用例<code>[1,2,3,4,5,6]</code>,会直接遍历完第一个序列不进行第二步操作，返回的结果是True, </li><li>当给测试用例<code>[6,5,4,3,2,1]</code>,同理，在第二步直接遍历完，也返回了True；但是这种纯递减和纯递增序列并不是山脉数组。</li></ol></blockquote><p>那么问题来了，如何去判断它是不是一个纯递减或者纯递增序列呢？</p><p>解决办法来了： <strong>判断峰值是否是第一位且最后一位，当都不是的时候肯定不是纯sort序列</strong></p><pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">"""author: jdi146contact: jdi147.com@gmail.comdatetime: 2020/11/3 13:08"""</span><span class="token triple-quoted-string string">'''parm：is_left: 标记找到峰值'''</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">validMountainArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        list_len <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">if</span> list_len <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        max_value <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        min_value <span class="token operator">=</span> None        is_left <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> list_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> max_value <span class="token operator">==</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> is_left<span class="token punctuation">:</span>                <span class="token keyword">if</span> max_value <span class="token operator">&lt;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    max_value <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    is_left <span class="token operator">=</span> <span class="token boolean">False</span>                    min_value <span class="token operator">=</span> max_value                <span class="token keyword">continue</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> min_value <span class="token operator">></span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    min_value <span class="token operator">=</span> A<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> max_value <span class="token operator">></span> A<span class="token punctuation">[</span>list_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">and</span> max_value <span class="token operator">></span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> min_value <span class="token operator">></span> A<span class="token punctuation">[</span>list_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        test_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>validMountainArray<span class="token punctuation">(</span>test_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">"""测试用例[3,7,20,14,15,14,10,8,2,1]: seq中20,14,15 ，在寻找max_value 的过程中，i 会多前进一位，所有在后半部分 判断中是用的 A[i-1],以及在最后 return中判断最后一个元素[1,2,3,4,5,6]: max_value > A[0]，[6,5,4,3,2,1]: max_value > A[list_len-1].O(n) / O(1)"""</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    solution<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>原题链接[<a href="https://leetcode-cn.com/problems/valid-mountain-array/">941. 有效的山脉数组</a>]</p><p>其他想法：</p><blockquote><ol><li>二分法递归找峰值判断，O(logn)</li></ol></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> daily_leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery record</title>
      <link href="/2020/08/21/hexo-matery-record/"/>
      <url>/2020/08/21/hexo-matery-record/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">1 前言</h1><p>忙了两天终于搭建了自己的博客，win下hexo+github+matery。其中踩坑不少，还要很多地方需要完善、精化。写下这篇有博客以来的第一篇文章以记录后续的改善。</p><p>先在此记录一下待解决问题：</p><blockquote><ol><li>使用官方推荐的插件代码高亮,{}不能被正确转义, 目前的方法是降 hexo 的版本(4.2没有这个问题),等GitHub的issue solution吧.</li><li>valine 升级1.4.1后在Google中显示问题, Firefox倒是没有.</li><li>目录想设置个多级分类, finding </li><li>写个脚本, 在typora书写中,获取当前时间戳.</li><li>有时间搞个文章加密插件</li><li>针对特定文章关闭评论</li><li>关闭友链区的评论</li><li>logo有时间精化一下</li><li>seo优化，</li><li>百度统计，Google统计</li><li>再多就有点花里胡哨了，就这样</li></ol></blockquote><h1 id="toc显示问题-以及-配置标题自动编号">2 toc显示问题 以及 配置标题自动编号</h1><blockquote><p>发现一级标题不能在toc显示，以为是bug，后来发现主题默认toc开启的是h2,h3,h4, 于是修改为h1, h2, h3.</p></blockquote><p><strong>标题自动编号</strong>: </p><ol><li>win下 安装插件 hexo-heading-index</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-heading-index --save</code></pre><ol start="2"><li>根目录配置：<pre class=" language-yml"><code class="language-yml">heading_index: enable: true index_styles: "&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;" connector: "." global_prefix: "" global_suffix: " "</code></pre>关于具体的配置信息，参考<a href="https://github.com/r12f/hexo-heading-index">hexo-heading-index </a></li></ol><p>到此，clean, g, d 后，发现目录变成了这样：</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/hexo/%E6%89%B9%E6%B3%A8%202020-08-21%20220912.png" alt="批注 2020-08-21 220912"></p><p>但是，这个设置时针对全局的，这意味这只要在其他地方使用了层级符号，那么也会带有“数字”，为了避免这个情况，有两种解决办法。</p><blockquote><ol><li>在其他地方不使用层级符号 fh不是</li><li>设置heading-index 前几级编号，后几级使用肯定不会显示数字。</li></ol></blockquote><p>针对第二种方法，需要修改 hexo-heading-index/lib/index.js 文件</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">updateHeadingIndexes</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> $ <span class="token operator">=</span> cheerio<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> decodeEntities<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> headings <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'h1, h2, h3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在这里, 保留几级看个人使用喜好</span></code></pre><p><strong># end</strong></p><h1 id="利用脚本写入文章更新时间">3 利用脚本写入文章更新时间</h1><p>想每次写完文章都记录一下文章的更新时间，方便纠错以及提供时间线。</p><p>此脚本可以给所有脚本加时间戳以及给单个文件加时间戳。</p><p><strong><em>关于更多的实用 blog 脚本, 可以访问我的GitHub，地址：<a href="https://github.com/diuzi/blog_script">blog_script</a>, 喜欢的话star一下，谢谢。</em></strong></p><p>代码如下:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> sys<span class="token keyword">import</span> glob<span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">get_stamp</span><span class="token punctuation">(</span>post_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    :param post_name:    :return:  null    """</span>    time_stamp <span class="token operator">=</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%Y-%m-%d-%H-%M-%S'</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">write_stamp</span><span class="token punctuation">(</span>file_name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :param file_name:        :return: null        """</span>        <span class="token keyword">with</span> open<span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> <span class="token string">"a+"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"> ___#end___ 以上内容于 "</span> <span class="token operator">+</span> time_stamp <span class="token operator">+</span> <span class="token string">" 更新"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token triple-quoted-string string">""" 所有文件加时间戳 """</span>    <span class="token keyword">if</span> post_name <span class="token operator">==</span> <span class="token string">"all"</span><span class="token punctuation">:</span>        filename <span class="token operator">=</span> <span class="token string">"../source/_posts/*.md"</span>        <span class="token keyword">for</span> name <span class="token keyword">in</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>            write_stamp<span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""单个文件加时间戳 """</span>        filename <span class="token operator">=</span> <span class="token string">"../source/_posts/"</span> <span class="token operator">+</span> post_name <span class="token operator">+</span> <span class="token string">".md"</span>        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>            write_stamp<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"filename error\n"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">and</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"get_stamp.py"</span><span class="token punctuation">:</span>        get_stamp<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"command error\n"</span><span class="token punctuation">)</span></code></pre><p>首先在博客根目录下新建目录my_script，并将python脚本以get_stamp.py命名并放入此目录。在此目录下打开bash，运行以下命令</p><blockquote><p>单个文件加时间戳，postname为你要加时间戳的md文件</p></blockquote><pre class=" language-bash"><code class="language-bash"> python get_stamp.py postname</code></pre><blockquote><p>所有博客目录下所有md文件加时间戳</p></blockquote><pre class=" language-bash"><code class="language-bash"> python get_stamp.py all</code></pre><p>效果如下：</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/hexo/%E6%97%B6%E9%97%B4%E6%88%B3%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.png" alt="时间戳效果展示"></p><p><strong>当然，你也可以在此脚本的基础上进行修改以适配其他情况, 以及增加功能</strong></p><blockquote><p><strong><em>#end</em></strong> 以上内容于 2020-08-22-00-50-07 更新</p></blockquote><h1 id="关闭友链区评论，md页放上面。">4 关闭友链区评论，md页放上面。</h1><h1 id="文章加密">5 文章加密</h1><p>发现文章已经配置了加密功能，只需要在主题中开启配置即可。</p><p>简单写了个轮子，实用性一般般的样子，bash命令下给文档加密，缺点是需要一次性读文件，当文章特别长时。。。不过这种极端情况很少，折腾试试，直接贴代码 ：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> hashlib<span class="token keyword">import</span> sys<span class="token keyword">import</span> glob<span class="token keyword">import</span> os<span class="token keyword">import</span> frontmatter<span class="token keyword">def</span> <span class="token function">encrypt_md</span><span class="token punctuation">(</span>post_name<span class="token punctuation">,</span> raw_pwd<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    generate and write hash256 pwd    :param post_name:  md filename    :param raw_pwd:    :return:  null    """</span>    <span class="token keyword">def</span> <span class="token function">gen_pwd</span><span class="token punctuation">(</span>raw_pwd<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :param raw_pwd:        :return:        """</span>        hash256 <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>sha256<span class="token punctuation">(</span><span class="token punctuation">)</span>        hash256<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">(</span>raw_pwd<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> hash256<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">w_pwd</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> hash_pwd<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :param name:        :param pwd:        :return:        """</span>        <span class="token keyword">with</span> open<span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"r+"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>            md <span class="token operator">=</span> frontmatter<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span>            md<span class="token punctuation">.</span>metadata<span class="token punctuation">[</span><span class="token string">"password"</span><span class="token punctuation">]</span> <span class="token operator">=</span> hash_pwd            f<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>frontmatter<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>md<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token triple-quoted-string string">""" 所有文件加密 """</span>    <span class="token keyword">if</span> post_name <span class="token operator">==</span> <span class="token string">"all"</span><span class="token punctuation">:</span>        dir_name <span class="token operator">=</span> <span class="token string">"../source/_posts/*.md"</span>        <span class="token keyword">for</span> filename <span class="token keyword">in</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span>dir_name<span class="token punctuation">)</span><span class="token punctuation">:</span>            w_pwd<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> gen_pwd<span class="token punctuation">(</span>raw_pwd<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">""" 单个文件加密"""</span>        filename <span class="token operator">=</span> <span class="token string">"../source/_posts/"</span> <span class="token operator">+</span> post_name <span class="token operator">+</span> <span class="token string">".md"</span>        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>            w_pwd<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> gen_pwd<span class="token punctuation">(</span>raw_pwd<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"filename error\n"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">and</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"encrypt.py"</span><span class="token punctuation">:</span>        encrypt_md<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"command error\n"</span><span class="token punctuation">)</span></code></pre><p>使用方法：</p><blockquote><p>如果你的根目录下还没有 _my_script_ 文件，那就新建一个，将代码写到该文件夹下，encrpt.py  命名，</p></blockquote><ol><li>单个文件加密,在 <code>my_script</code>目录下开启bash, win下执行命令，其他环境参考</li></ol><pre class=" language-bash"><code class="language-bash"> python encrypt.py postname password</code></pre><ol start="2"><li>多个 md 文件加密</li></ol><pre class=" language-bash"><code class="language-bash"> python encrypt.py all password</code></pre><p><strong>其中，<code>postname</code> 加密的md文件名， <code>password</code> 是要 设置的密码，注意密码不能含有空格。另外，如果还没有 frontmatter 包，需要进行安装。另外，网站填写密码是原生 <code>password</code> , 非md文件中的。</strong></p><p>pip安装命令：</p><pre class=" language-cmd"><code class="language-cmd">pip install python-frontmatter</code></pre><p><strong><em>关于更多的实用 blog 脚本, 可以访问我的GitHub，地址：<a href="https://github.com/diuzi/blog_script">blog_script</a>, 喜欢的话 star一下，谢谢。</em></strong></p><blockquote><p><strong><em>#end</em></strong> 以上内容于 2020-08-22-10-17-05 更新</p></blockquote><h1 id="seo优化">6 seo优化</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/08/21/test/"/>
      <url>/2020/08/21/test/</url>
      
        <content type="html"><![CDATA[<p>如果你看到这里的内容，那说明这个加密插件真的很L</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linkedList</title>
      <link href="/2020/08/21/linkedList/"/>
      <url>/2020/08/21/linkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="链表">1 链表</h1><blockquote><p><strong><em>插入的时候，单链表/双链表(先接后面)</em></strong><br><strong><em>往后移，前面的先移动，往前移动，后面的先移动。</em></strong></p></blockquote><p>与数组不同，我们无法在常量时间内访问单链表中的随机元素。<br> 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。<br>我们按索引来访问元素平均要花费 O(N) 时间，其中 N 是链表的长度。</p><p>尽管它在通过索引访问数据时（与数组相比）具有如此糟糕的性能。<br>插入和删除操作，将了解到链表的好处。</p><ol><li><p>在 O(1) 时间复杂度中将新结点插入到链表中，这非常高效。</p></li><li><p>删除结点的时间复杂度将是 O(N)。空间复杂度为 O(1)，因为我们只需要常量空间来存储指针。</p></li></ol><h1 id="链表中的双指针">2 链表中的双指针</h1><h2 id="循环链表">2.1 循环链表</h2><blockquote><p>给定一个链表，判断链表中是否有环</p></blockquote><p><strong><em>在链表中使用两个速度不同的指针时会遇到的情况:</em></strong></p><blockquote><p><strong>如果没有环，快指针将停在链表的末尾。</strong><br><strong>如果有环，快指针最终将与慢指针相遇。</strong></p></blockquote><p><strong><em>这两个指针的适当速度应该是多少？</em></strong><br>一个安全的选择是每次移动慢指针一步，而移动快指针两步。每一次迭代，快速指针将额外移动一步。如果环的长度为 M，经过 M 次迭代后，快指针肯定会多绕环一周，并赶上慢指针。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> null <span class="token operator">||</span> fast<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>方法2，哈希表</strong></p><blockquote><p>我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> nodesSeen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodesSeen<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            nodesSeen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="循环链表2">2.2 循环链表2</h2><p><strong><em>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</em></strong></p><ol><li>快指针1次走2步，慢指针1次走1步。所以快指针总是走了慢指针两倍的路。</li><li>回顾一下阶段1的过程，设头节点到入环点的路途为 n, 那么慢指针走了入环路途的一半（n/2）时，快指针就到达入环点了(走完n了)。</li><li>慢指针再继续走完剩下的一般入环路途（剩下的n/2），到达入环点时，快指针已经在环内又走了一个 n 那么远的路了。</li><li>为了方便理解，这里先讨论环很大，大于n的情况（其他情况后文补充）。此时，慢指针正处于入环点，快指针距离入环点的距离为n。环内路，可以用此时快指针的位置分割为两段，前面的 n 部分，和后面的 b 部分。</li><li>此时开始继续快慢指针跑圈，因为已经在环内了，他们其实就是在一条nbnbnbnbnbnbnb（无尽nb路）上跑步。</li><li>慢指针从入环处开始跑b步，距离入环处就剩下了n。此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。他们相遇了，并且距离入环处的距离就是n，n就是头节点到入环点的距离阿!!! 后面的不用说了吧。</li></ol><p>环很小的情况，其实跟环很大是一样的，比如你可以理解为将多个小环的循环铺开，虚拟扩展成一个大环来理解。</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/imgx/image.png"><br><strong>假设 节点到入环口长为 L，环长为C</strong><br>这里简单讨论C&gt;L的情况, 即一个大环（slow在走到入环口处，fast还没有遍历一遍环)</p><blockquote><ol><li>slow到达入口处时，fast 在环 <strong>L%C</strong>  的位置(slow走L，fast走2L)</li><li>设 slow 继续行进 t 长 时，两者相遇， 此时有方程: <strong><em>(L%C+2t)%C = t%C</em></strong></li><li>则 有 L%C + 2t = t+ nC —&gt; L%C+2t = t+nC</li><li>C&gt;L, 取n=1,得 t = C - L%C, 相遇，L%C=L, 即 目前两者处在环 C-L处，再走 L 长便可到达 入环处<br><strong>当C&lt;L，即小环时，n的取值较大，即两者绕环次数多一些，结果还是不变。</strong></li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 找到相遇点</span>    ListNode p1 <span class="token operator">=</span> <span class="token function">getIntersect</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode p2 <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 头节点到入环处的距离 和 相遇点行走到 入环处的距离 相等</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> p2<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p1<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h1 id="模板">3 模板</h1><h2 id="解决链表中的双指针">3.1 解决链表中的双指针</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 判断是否有环</span><span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// move slow pointer one step each time</span>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// move fast pointer two steps each time</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// change this condition to fit specific problem</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 寻找链表的 第一次相遇节点</span><span class="token keyword">private</span> ListNode <span class="token function">getIntersect</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ListNode slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span>            <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="列表反转">3.2 列表反转</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ListNode prev <span class="token operator">=</span> null<span class="token punctuation">;</span>    ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ListNode nextTemp <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        curr<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>        curr <span class="token operator">=</span> nextTemp<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> prev<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h1 id="要善用哑变量，特别是在删除的时候">4 要善用哑变量，特别是在删除的时候</h1><blockquote><p><em>删除链表中等于给定值 val 的所有节点。</em></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 巧用 哑变量</span>    <span class="token comment" spellcheck="true">/*        如果头或者前 n 个 都是要删除的变量， 这样操作比较麻烦         */</span>    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dummy<span class="token punctuation">.</span>next <span class="token operator">=</span>  head<span class="token punctuation">;</span>    ListNode cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span>  cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h1 id="递归的总结">5 递归的总结</h1><blockquote><p><em>删除链表中等于给定值 val 的所有节点。</em></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">solution</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*        和19题 有异曲同工之妙        1. 递归的结束条件时什么【走到最深处】        2. 子序列去递归【做什么】        3. 递归的返值是什么【向上返回】         */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> head <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span>            <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//return head->val == val ? head->next : head;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> data struct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linkedList </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

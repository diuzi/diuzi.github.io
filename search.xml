<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo-matery record</title>
      <link href="/2020/08/21/hexo-matery-record/"/>
      <url>/2020/08/21/hexo-matery-record/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">1 前言</h1><p>忙了两天终于搭建了自己的博客，win下hexo+github+matery。其中踩坑不少，还要很多地方需要完善、精化。写下这篇有博客以来的第一篇文章以记录后续的改善。</p><p>先在此记录一下待解决问题：</p><blockquote><ol><li>使用官方推荐的插件代码高亮,{}不能被正确转义, 目前的方法是降 hexo 的版本(4.2没有这个问题),等GitHub的issue solution吧.</li><li>valine 升级1.4.1后在Google中显示问题, Firefox倒是没有.</li><li>目录想设置个多级分类, finding </li><li>写个脚本, 在typora书写中,获取当前时间戳.</li><li>有时间搞个文章加密插件</li><li>针对特定文章关闭评论</li><li>关闭友链区的评论</li><li>logo有时间精化一下</li><li>seo优化，</li><li>百度统计，Google统计</li><li>再多就有点花里胡哨了，就这样</li></ol></blockquote><h1 id="toc显示问题-以及-配置标题自动编号">2 toc显示问题 以及 配置标题自动编号</h1><blockquote><p>发现一级标题不能在toc显示，以为是bug，后来发现主题默认toc开启的是h2,h3,h4, 于是修改为h1, h2, h3.</p></blockquote><p><strong>标题自动编号</strong>: </p><ol><li>win下 安装插件 hexo-heading-index</li></ol><figure class="highlight bash"><table><tbody><tr><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">npm install hexo-heading-index --save<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>根目录配置：<figure class="highlight yml"><table><tbody><tr><td class="code"><pre class=" language-hljs yml"><span class="hljs-attr">heading_index:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">index_styles:</span> <span class="hljs-string">"{1} {1} {1} {1} {1} {1}"</span><br>    <span class="hljs-attr">connector:</span> <span class="hljs-string">"."</span><br>    <span class="hljs-attr">global_prefix:</span> <span class="hljs-string">""</span><br>    <span class="hljs-attr">global_suffix:</span> <span class="hljs-string"><code class="language-hljs yml"><span class="hljs-attr">heading_index:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">index_styles:</span> <span class="hljs-string">"{1} {1} {1} {1} {1} {1}"</span><br>    <span class="hljs-attr">connector:</span> <span class="hljs-string">"."</span><br>    <span class="hljs-attr">global_prefix:</span> <span class="hljs-string">""</span><br>    <span class="hljs-attr">global_suffix:</span> <span class="hljs-string">" "</span><br></code></pre></td></tr></tbody></table></figure>关于具体的配置信息，参考<a href="https://github.com/r12f/hexo-heading-index">hexo-heading-index </a></li></ol><p>到此，clean, g, d 后，发现目录变成了这样：</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/hexo/%E6%89%B9%E6%B3%A8%202020-08-21%20220912.png" alt="批注 2020-08-21 220912"></p><p>但是，这个设置时针对全局的，这意味这只要在其他地方使用了层级符号，那么也会带有“数字”，为了避免这个情况，有两种解决办法。</p><blockquote><ol><li>在其他地方不使用层级符号(fh不是)</li><li>设置heading-index 前几级编号，后几级使用肯定不会显示数字。</li></ol></blockquote><p>针对第二种方法，需要修改 hexo-heading-index/lib/index.js 文件</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre class=" language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHeadingIndexes</span>(<span class="hljs-params">options, data</span>) </span>{<br>    <span class="hljs-keyword">var</span> $ = cheerio.load(data, { <span class="hljs-attr">decodeEntities</span>: <span class="hljs-literal">false</span> });<br>    <span class="hljs-keyword">var</span> headings = $(<span class="hljs-string">'h1, h2, h3'</span>); <span class="hljs-comment"><code class="language-hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHeadingIndexes</span>(<span class="hljs-params">options, data</span>) </span>{<br>    <span class="hljs-keyword">var</span> $ = cheerio.load(data, { <span class="hljs-attr">decodeEntities</span>: <span class="hljs-literal">false</span> });<br>    <span class="hljs-keyword">var</span> headings = $(<span class="hljs-string">'h1, h2, h3'</span>); <span class="hljs-comment">// 在这里, 保留几级看个人使用喜好</span><br></code></pre></td></tr></tbody></table></figure><p><strong># end</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linkedList</title>
      <link href="/2020/08/21/linkedList/"/>
      <url>/2020/08/21/linkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="链表">1 链表</h1><blockquote><p><strong><em>插入的时候，单链表/双链表(先接后面)</em></strong><br><strong><em>往后移，前面的先移动，往前移动，后面的先移动。</em></strong></p></blockquote><p>与数组不同，我们无法在常量时间内访问单链表中的随机元素。<br> 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。<br>我们按索引来访问元素平均要花费 O(N) 时间，其中 N 是链表的长度。</p><p>尽管它在通过索引访问数据时（与数组相比）具有如此糟糕的性能。<br>插入和删除操作，将了解到链表的好处。</p><ol><li><p>在 O(1) 时间复杂度中将新结点插入到链表中，这非常高效。</p></li><li><p>删除结点的时间复杂度将是 O(N)。空间复杂度为 O(1)，因为我们只需要常量空间来存储指针。</p></li></ol><h1 id="链表中的双指针">2 链表中的双指针</h1><h2 id="循环链表">2.1 循环链表</h2><blockquote><p>给定一个链表，判断链表中是否有环</p></blockquote><p><strong><em>在链表中使用两个速度不同的指针时会遇到的情况:</em></strong></p><blockquote><p><strong>如果没有环，快指针将停在链表的末尾。</strong><br><strong>如果有环，快指针最终将与慢指针相遇。</strong></p></blockquote><p><strong><em>这两个指针的适当速度应该是多少？</em></strong><br>一个安全的选择是每次移动慢指针一步，而移动快指针两步。每一次迭代，快速指针将额外移动一步。如果环的长度为 M，经过 M 次迭代后，快指针肯定会多绕环一周，并赶上慢指针。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    }<br>    ListNode slow = head;<br>    ListNode fast = head.next;<br>    <span class="hljs-keyword">while</span> (slow != fast) {<br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        }<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    }<br>    ListNode slow = head;<br>    ListNode fast = head.next;<br>    <span class="hljs-keyword">while</span> (slow != fast) {<br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        }<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>方法2，哈希表</strong></p><blockquote><p>我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    Set&lt;ListNode&gt; nodesSeen = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-keyword">if</span> (nodesSeen.contains(head)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            nodesSeen.add(head);<br>        }<br>        head = head.next;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    Set&lt;ListNode&gt; nodesSeen = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) {<br>        <span class="hljs-keyword">if</span> (nodesSeen.contains(head)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            nodesSeen.add(head);<br>        }<br>        head = head.next;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="循环链表2">2.2 循环链表2</h2><p><strong><em>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</em></strong></p><ol><li>快指针1次走2步，慢指针1次走1步。所以快指针总是走了慢指针两倍的路。</li><li>回顾一下阶段1的过程，设头节点到入环点的路途为 n, 那么慢指针走了入环路途的一半（n/2）时，快指针就到达入环点了(走完n了)。</li><li>慢指针再继续走完剩下的一般入环路途（剩下的n/2），到达入环点时，快指针已经在环内又走了一个 n 那么远的路了。</li><li>为了方便理解，这里先讨论环很大，大于n的情况（其他情况后文补充）。此时，慢指针正处于入环点，快指针距离入环点的距离为n。环内路，可以用此时快指针的位置分割为两段，前面的 n 部分，和后面的 b 部分。</li><li>此时开始继续快慢指针跑圈，因为已经在环内了，他们其实就是在一条nbnbnbnbnbnbnb（无尽nb路）上跑步。</li><li>慢指针从入环处开始跑b步，距离入环处就剩下了n。此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。他们相遇了，并且距离入环处的距离就是n，n就是头节点到入环点的距离阿!!! 后面的不用说了吧。</li></ol><p>环很小的情况，其实跟环很大是一样的，比如你可以理解为将多个小环的循环铺开，虚拟扩展成一个大环来理解。</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/imgx/image.png"><br><strong>假设 节点到入环口长为 L，环长为C</strong><br>这里简单讨论C&gt;L的情况, 即一个大环（slow在走到入环口处，fast还没有遍历一遍环)</p><blockquote><ol><li>slow到达入口处时，fast 在环 <strong>L%C</strong>  的位置(slow走L，fast走2L)</li><li>设 slow 继续行进 t 长 时，两者相遇， 此时有方程: <strong><em>(L%C+2t)%C = t%C</em></strong></li><li>则 有 L%C + 2t = t+ nC —&gt; L%C+2t = t+nC</li><li>C&gt;L, 取n=1,得 t = C - L%C, 相遇，L%C=L, 即 目前两者处在环 C-L处，再走 L 长便可到达 入环处<br><strong>当C&lt;L，即小环时，n的取值较大，即两者绕环次数多一些，结果还是不变。</strong></li></ol></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 找到相遇点</span><br>    ListNode p1 = getIntersect(head);<br>    ListNode p2 = head;<br>    <span class="hljs-keyword">if</span>(p1 == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 头节点到入环处的距离 和 相遇点行走到 入环处的距离 相等</span><br>    <span class="hljs-keyword">while</span>(p1 != p2){<br>        p1 = p1.next;<br>        p2 = p2.next;<br>    }<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 找到相遇点</span><br>    ListNode p1 = getIntersect(head);<br>    ListNode p2 = head;<br>    <span class="hljs-keyword">if</span>(p1 == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 头节点到入环处的距离 和 相遇点行走到 入环处的距离 相等</span><br>    <span class="hljs-keyword">while</span>(p1 != p2){<br>        p1 = p1.next;<br>        p2 = p2.next;<br>    }<br>    <span class="hljs-keyword">return</span> p1;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="模板">3 模板</h1><h2 id="解决链表中的双指针">3.1 解决链表中的双指针</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// 判断是否有环</span><br><span class="hljs-keyword">while</span> (slow != <span class="hljs-keyword">null</span> &amp;&amp; fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) {<br>    slow = slow.next;           <span class="hljs-comment">// move slow pointer one step each time</span><br>    fast = fast.next.next;      <span class="hljs-comment">// move fast pointer two steps each time</span><br>    <span class="hljs-keyword">if</span> (slow == fast) {         <span class="hljs-comment">// change this condition to fit specific problem</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 寻找链表的 第一次相遇节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">getIntersect</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    ListNode slow = head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast!=<span class="hljs-keyword">null</span> &amp;&amp; fast.next!=<span class="hljs-keyword">null</span>){<br>        slow = slow.next;<br>        fast = fast.next.next;<br><br>        <span class="hljs-keyword">if</span>(slow == fast)<br>            <span class="hljs-keyword">return</span> slow;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-comment">// 判断是否有环</span><br><span class="hljs-keyword">while</span> (slow != <span class="hljs-keyword">null</span> &amp;&amp; fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) {<br>    slow = slow.next;           <span class="hljs-comment">// move slow pointer one step each time</span><br>    fast = fast.next.next;      <span class="hljs-comment">// move fast pointer two steps each time</span><br>    <span class="hljs-keyword">if</span> (slow == fast) {         <span class="hljs-comment">// change this condition to fit specific problem</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 寻找链表的 第一次相遇节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">getIntersect</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    ListNode slow = head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast!=<span class="hljs-keyword">null</span> &amp;&amp; fast.next!=<span class="hljs-keyword">null</span>){<br>        slow = slow.next;<br>        fast = fast.next.next;<br><br>        <span class="hljs-keyword">if</span>(slow == fast)<br>            <span class="hljs-keyword">return</span> slow;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="列表反转">3.2 列表反转</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    ListNode prev = <span class="hljs-keyword">null</span>;<br>    ListNode curr = head;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-keyword">null</span>) {<br>        ListNode nextTemp = curr.next;<br>        curr.next = prev;<br>        prev = curr;<br>        curr = nextTemp;<br>    }<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>{<br>    ListNode prev = <span class="hljs-keyword">null</span>;<br>    ListNode curr = head;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-keyword">null</span>) {<br>        ListNode nextTemp = curr.next;<br>        curr.next = prev;<br>        prev = curr;<br>        curr = nextTemp;<br>    }<br>    <span class="hljs-keyword">return</span> prev;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="要善用哑变量，特别是在删除的时候">4 要善用哑变量，特别是在删除的时候</h1><blockquote><p><em>删除链表中等于给定值 val 的所有节点。</em></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre class=" language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>{<br><br>    <span class="hljs-comment">// 巧用 哑变量</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        如果头或者前 n 个 都是要删除的变量， 这样操作比较麻烦</span><br><span class="hljs-comment">         */</span><br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    dummy.next =  head;<br>    ListNode cur = dummy;<br><br>    <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-keyword">null</span>){<br>        <span class="hljs-keyword">if</span>(cur.next.val == val){<br>            cur.next =  cur.next.next;<br>        }<br>        <span class="hljs-keyword">else</span><br>            cur = cur.next;<br>    }<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>{<br><br>    <span class="hljs-comment">// 巧用 哑变量</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        如果头或者前 n 个 都是要删除的变量， 这样操作比较麻烦</span><br><span class="hljs-comment">         */</span><br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    dummy.next =  head;<br>    ListNode cur = dummy;<br><br>    <span class="hljs-keyword">while</span>(cur.next!=<span class="hljs-keyword">null</span>){<br>        <span class="hljs-keyword">if</span>(cur.next.val == val){<br>            cur.next =  cur.next.next;<br>        }<br>        <span class="hljs-keyword">else</span><br>            cur = cur.next;<br>    }<br>    <span class="hljs-keyword">return</span> dummy.next;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="递归的总结">5 递归的总结</h1><blockquote><p><em>删除链表中等于给定值 val 的所有节点。</em></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre class=" language-hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">solution</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>{<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        和19题 有异曲同工之妙</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        1. 递归的结束条件时什么【走到最深处】</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        2. 子序列去递归【做什么】</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        3. 递归的返值是什么【向上返回】</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-keyword">if</span>( head == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        head.next = removeElements(head.next, val);<br><br>        <span class="hljs-keyword">if</span>(head.val == val)<br>            <span class="hljs-keyword">return</span> head.next;<br>        <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">solution</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>{<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        和19题 有异曲同工之妙</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        1. 递归的结束条件时什么【走到最深处】</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        2. 子序列去递归【做什么】</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        3. 递归的返值是什么【向上返回】</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-keyword">if</span>( head == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        head.next = removeElements(head.next, val);<br><br>        <span class="hljs-keyword">if</span>(head.val == val)<br>            <span class="hljs-keyword">return</span> head.next;<br>        <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//return head->val == val ? head->next : head;</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> data struct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linkedList </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linkedList</title>
      <link href="/2020/08/21/linkedList/"/>
      <url>/2020/08/21/linkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="链表">1 链表</h1><blockquote><p><strong><em>插入的时候，单链表/双链表(先接后面)</em></strong><br><strong><em>往后移，前面的先移动，往前移动，后面的先移动。</em></strong></p></blockquote><p>与数组不同，我们无法在常量时间内访问单链表中的随机元素。<br> 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。<br>我们按索引来访问元素平均要花费 O(N) 时间，其中 N 是链表的长度。</p><p>尽管它在通过索引访问数据时（与数组相比）具有如此糟糕的性能。<br>插入和删除操作，将了解到链表的好处。</p><ol><li><p>在 O(1) 时间复杂度中将新结点插入到链表中，这非常高效。</p></li><li><p>删除结点的时间复杂度将是 O(N)。空间复杂度为 O(1)，因为我们只需要常量空间来存储指针。</p></li></ol><h1 id="链表中的双指针">2 链表中的双指针</h1><h2 id="循环链表">2.1 循环链表</h2><blockquote><p>给定一个链表，判断链表中是否有环</p></blockquote><p><strong><em>在链表中使用两个速度不同的指针时会遇到的情况:</em></strong></p><blockquote><p><strong>如果没有环，快指针将停在链表的末尾。</strong><br><strong>如果有环，快指针最终将与慢指针相遇。</strong></p></blockquote><p><strong><em>这两个指针的适当速度应该是多少？</em></strong><br>一个安全的选择是每次移动慢指针一步，而移动快指针两步。每一次迭代，快速指针将额外移动一步。如果环的长度为 M，经过 M 次迭代后，快指针肯定会多绕环一周，并赶上慢指针。</p><pre class="language-java" data-language="java"><code class="language-java">public boolean hasCycle(ListNode head) {    if (head == null || head.next == null) {        return false;    }    ListNode slow = head;    ListNode fast = head.next;    while (slow != fast) {        if (fast == null || fast.next == null) {            return false;        }        slow = slow.next;        fast = fast.next.next;    }    return true;}</code></pre><p><strong>方法2，哈希表</strong></p><blockquote><p>我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）</p></blockquote><pre class="language-java" data-language="java"><code class="language-java">public boolean hasCycle(ListNode head) {    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();    while (head != null) {        if (nodesSeen.contains(head)) {            return true;        } else {            nodesSeen.add(head);        }        head = head.next;    }    return false;}</code></pre><h2 id="循环链表2">2.2 循环链表2</h2><p><strong><em>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</em></strong></p><ol><li>快指针1次走2步，慢指针1次走1步。所以快指针总是走了慢指针两倍的路。</li><li>回顾一下阶段1的过程，设头节点到入环点的路途为 n, 那么慢指针走了入环路途的一半（n/2）时，快指针就到达入环点了(走完n了)。</li><li>慢指针再继续走完剩下的一般入环路途（剩下的n/2），到达入环点时，快指针已经在环内又走了一个 n 那么远的路了。</li><li>为了方便理解，这里先讨论环很大，大于n的情况（其他情况后文补充）。此时，慢指针正处于入环点，快指针距离入环点的距离为n。环内路，可以用此时快指针的位置分割为两段，前面的 n 部分，和后面的 b 部分。</li><li>此时开始继续快慢指针跑圈，因为已经在环内了，他们其实就是在一条nbnbnbnbnbnbnb（无尽nb路）上跑步。</li><li>慢指针从入环处开始跑b步，距离入环处就剩下了n。此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。他们相遇了，并且距离入环处的距离就是n，n就是头节点到入环点的距离阿!!! 后面的不用说了吧。</li></ol><p>环很小的情况，其实跟环很大是一样的，比如你可以理解为将多个小环的循环铺开，虚拟扩展成一个大环来理解。</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/imgx/image.png"><br><strong>假设 节点到入环口长为 L，环长为C</strong><br>这里简单讨论C&gt;L的情况, 即一个大环（slow在走到入环口处，fast还没有遍历一遍环)</p><blockquote><ol><li>slow到达入口处时，fast 在环 <strong>L%C</strong>  的位置(slow走L，fast走2L)</li><li>设 slow 继续行进 t 长 时，两者相遇， 此时有方程: <strong><em>(L%C+2t)%C = t%C</em></strong></li><li>则 有 L%C + 2t = t+ nC —&gt; L%C+2t = t+nC</li><li>C&gt;L, 取n=1,得 t = C - L%C, 相遇，L%C=L, 即 目前两者处在环 C-L处，再走 L 长便可到达 入环处<br><strong>当C&lt;L，即小环时，n的取值较大，即两者绕环次数多一些，结果还是不变。</strong></li></ol></blockquote><pre class="language-java" data-language="java"><code class="language-java">public ListNode detectCycle(ListNode head) {    if(head == null)        return null;    // 找到相遇点    ListNode p1 = getIntersect(head);    ListNode p2 = head;    if(p1 == null)        return null;    // 头节点到入环处的距离 和 相遇点行走到 入环处的距离 相等    while(p1 != p2){        p1 = p1.next;        p2 = p2.next;    }    return p1;}</code></pre><h1 id="模板">3 模板</h1><h2 id="解决链表中的双指针">3.1 解决链表中的双指针</h2><pre class="language-java" data-language="java"><code class="language-java">// 判断是否有环while (slow != null &amp;&amp; fast != null &amp;&amp; fast.next != null) {    slow = slow.next;           // move slow pointer one step each time    fast = fast.next.next;      // move fast pointer two steps each time    if (slow == fast) {         // change this condition to fit specific problem        return true;    }}// 寻找链表的 第一次相遇节点private ListNode getIntersect(ListNode head) {    ListNode slow = head, fast = head;    while (fast!=null &amp;&amp; fast.next!=null){        slow = slow.next;        fast = fast.next.next;        if(slow == fast)            return slow;    }    return null;}</code></pre><h2 id="列表反转">3.2 列表反转</h2><pre class="language-java" data-language="java"><code class="language-java">private ListNode reverseList(ListNode head) {    ListNode prev = null;    ListNode curr = head;    while (curr != null) {        ListNode nextTemp = curr.next;        curr.next = prev;        prev = curr;        curr = nextTemp;    }    return prev;}</code></pre><h1 id="要善用哑变量，特别是在删除的时候">4 要善用哑变量，特别是在删除的时候</h1><blockquote><p><em>删除链表中等于给定值 val 的所有节点。</em></p></blockquote><pre class="language-java" data-language="java"><code class="language-java">public ListNode removeElements(ListNode head, int val) {    // 巧用 哑变量    /*        如果头或者前 n 个 都是要删除的变量， 这样操作比较麻烦         */    ListNode dummy = new ListNode(-1);    dummy.next =  head;    ListNode cur = dummy;    while(cur.next!=null){        if(cur.next.val == val){            cur.next =  cur.next.next;        }        else            cur = cur.next;    }    return dummy.next;}</code></pre><h1 id="递归的总结">5 递归的总结</h1><blockquote><p><em>删除链表中等于给定值 val 的所有节点。</em></p></blockquote><pre class="language-java" data-language="java"><code class="language-java">class solution {    public ListNode removeElements(ListNode head, int val) {        /*        和19题 有异曲同工之妙        1. 递归的结束条件时什么【走到最深处】        2. 子序列去递归【做什么】        3. 递归的返值是什么【向上返回】         */        if( head == null)            return null;        head.next = removeElements(head.next, val);        if(head.val == val)            return head.next;        return head;        //return head-&gt;val == val ? head-&gt;next : head;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> data struct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery record</title>
      <link href="/2020/08/21/hexo-matery-record/"/>
      <url>/2020/08/21/hexo-matery-record/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">1 前言</h1><p>忙了两天终于搭建了自己的博客，win下hexo+github+matery。其中踩坑不少，还要很多地方需要完善、精化。写下这篇有博客以来的第一篇文章以记录后续的改善。</p><p>先在此记录一下待解决问题：</p><blockquote><ol><li>使用官方推荐的插件代码高亮,{}不能被正确转义, 目前的方法是降 hexo 的版本(4.2没有这个问题),等GitHub的issue solution吧.</li><li>valine 升级1.4.1后在Google中显示问题, Firefox倒是没有.</li><li>目录想设置个多级分类, finding </li><li>写个脚本, 在typora书写中,获取当前时间戳.</li><li>有时间搞个文章加密插件</li><li>针对特定文章关闭评论</li><li>关闭友链区的评论</li><li>logo有时间精化一下</li><li>seo优化，</li><li>百度统计，Google统计</li><li>再多就有点花里胡哨了，就这样</li></ol></blockquote><h1 id="toc显示问题-以及-配置标题自动编号">2 toc显示问题 以及 配置标题自动编号</h1><blockquote><p>发现一级标题不能在toc显示，以为是bug，后来发现主题默认toc开启的是h2,h3,h4, 于是修改为h1, h2, h3.</p></blockquote><p><strong>标题自动编号</strong>: </p><ol><li>安装插件 hexo-heading-index</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">sudo npm install hexo-heading-index --save</code></pre><ol start="2"><li>根目录配置：<pre class="language-yml" data-language="yml"><code class="language-yml">heading_index:enable: trueindex_styles: "{1} {1} {1} {1} {1} {1}"connector: "."global_prefix: ""global_suffix: " "</code></pre>关于具体的配置信息，参考<a href="https://github.com/r12f/hexo-heading-index">hexo-heading-index </a></li></ol><p>到此，clean, g, d 后，发现目录变成了这样：</p><p><img src="https://gitee.com/diuzi/hexoImage/raw/master/img/hexo/%E6%89%B9%E6%B3%A8%202020-08-21%20220912.png" alt="批注 2020-08-21 220912"></p><p>但是，这个设置时针对全局的，这意味这只要在其他地方使用了层级符号，那么也会带有“数字”，为了避免这个情况，有两种解决办法。</p><blockquote><ol><li>在其他地方不使用层级符号(fh不是)</li><li>设置heading-index 前几级编号，后几级使用肯定不会显示数字。</li></ol></blockquote><p>针对第二种方法，需要修改<code>hexo-heading-index/lib/index.js</code>文件</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">updateHeadingIndexes</span><span class="token punctuation">(</span><span class="token parameter">options<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> $ <span class="token operator">=</span> cheerio<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> decodeEntities<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> headings <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'h1, h2, h3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在这里, 保留几级看个人使用喜好</span></code></pre><p><strong># end</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
